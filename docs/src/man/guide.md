# Package Guide

Documenter is designed to do one thing -- combine markdown files and inline docstrings from
Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide
intended for users who iteratively develop a package and write documentation for it.

## Preliminaries

As a package developer you want to keep a single Julia REPL session opened from which you
generate your docs. To make Julia aware of changes to your code and docstrings, you need to
install [Revise.jl](https://github.com/timholy/Revise.jl) first. Enter the Pkg REPL by
pressing `]` and run:

```
(@v1.5) pkg> add Revise

julia> using Revise
```


## Setting up the Package Structure

!!! note
    The function [`DocumenterTools.generate`](@ref) from the `DocumenterTools` package
    can generate the basic structure that Documenter expects.

Go back to the Pkg REPL and generate a new package:

```julia
(@v1.5) pkg> generate Example
 Generating  project Example:
    Example/Project.toml
    Example/src/Example.jl
```

By default the generated Example.jl file contains a `greet()` function. We're going to add a
docstring to it:

```julia
module Example

"""
    greet()

Prints "Hello world!"
"""
greet() = print("Hello World!")

end # module
```

Now create a `docs` folder within the package with the following structure:

```
Example/
├── docs
│   ├── make.jl
│   └── src
│       └── index.md
├── Project.toml
└── src
    └── Example.jl
```

The `make.jl` file should contain:

```julia
using Documenter, Example

makedocs(sitename="My Documentation")
```

and the `index.md` look as follows:

````
# Example.jl Documentation

```@docs
Example.greet()
```
````

Since Documenter is a development tool and not a true dependency of your package, create
a fresh environment in the `docs/` folder, and add Documenter and the Example package
itself as dependencies:

```julia
(@v1.5) pkg> activate Example/docs
 Activating new environment at `~/Documents/projects/Example/docs/Project.toml`

(docs) pkg> add Documenter

(docs) pkg> dev Example
[ Info: Resolving package identifier `Example` as a directory at `~/Documents/projects/Example`.
```

## Generating docs

In your REPL you can now include the `make.jl` script:

```julia
julia> cd("Example")

julia> include("docs/make.jl")
[ Info: Precompiling Example [86743d7e-c321-4af5-beac-c79b42746a03]
[ Info: SetupBuildDirectory: setting up build directory.
[ Info: Doctest: running doctests.
[ Info: ExpandTemplates: expanding markdown templates.
[ Info: CrossReferences: building cross-references.
[ Info: CheckDocument: running document checks.
[ Info: Populate: populating indices.
[ Info: RenderDocument: rendering document.
[ Info: HTMLWriter: rendering HTML pages.
```

After this, the `docs/` folder should contain a `build/index.html` file. Open this in your
browser to view the generated docs.

You can now start developing your package by adding more functions and docstrings and document
them further in `index.md`. Anytime you want to regenerate the docs, run
`include("docs/make.jl)` from the REPL and refresh the `index.html` page in your browser.

!!! note

    By default, Documenter has pretty URLs enabled, which means that `src/foo.md` is turned
    into `src/foo/index.html`, instead of simply `src/foo.html`, which is the preferred way
    when creating a set of HTML to be hosted on a web server.

    However, this can be a hindrance when browsing the documentation locally as browsers do
    not resolve directory URLs like `foo/` to `foo/index.html` for local files. You have two
    options:

    1. You can run a local web server out of the `docs/build` directory. One way to accomplish
       this is to install the [LiveServer](https://github.com/asprionj/LiveServer.jl) Julia
       package. You can then start the server with
       `julia -e 'using LiveServer; serve(dir="docs/build")'`. Alternatively, if you have Python
       installed, you can start one with `python3 -m http.server --bind localhost`
       (or `python -m SimpleHTTPServer` with Python 2).

    2. You can disable the pretty URLs feature by passing `prettyurls = false` with the
       [`Documenter.HTML`](@ref) plugin:

       ```julia
       makedocs(..., format = Documenter.HTML(prettyurls = false))
       ```

       Alternatively, if your goal is to eventually set up automatic documentation deployment
       with e.g. Travis CI or GitHub Actions (see [Hosting Documentation](@ref)), you can also use their environment
       variables to determine Documenter's behavior in `make.jl` on the fly:

       ```julia
       makedocs(...,
           format = Documenter.HTML(
               prettyurls = get(ENV, "CI", nothing) == "true"
           )
       )
       ```

!!! warning

    **Never** `git commit` the contents of `build` (or any other content generated by
    Documenter) to your repository's `master` branch. Always commit generated files to the
    `gh-pages` branch of your repository. This helps to avoid including unnecessary changes
    for anyone reviewing commits that happen to include documentation changes.

    See the [Hosting Documentation](@ref) section for details regarding how you should go
    about setting this up correctly.

### Filtering included docstrings

In some cases you may want to include a docstring for a `Method` that extends a
`Function` from a different module -- such as `Base`. In the following example we extend
`Base.length` with a new definition for the struct `T` and also add a docstring:

```julia
struct T
    # ...
end

"""
Custom `length` docs for `T`.
"""
Base.length(::T) = 1
```

When trying to include this docstring with

````markdown
```@docs
length
```
````

all the docs for `length` will be included -- even those from other modules. There are two
ways to solve this problem. Either include the type in the signature with

````markdown
```@docs
length(::T)
```
````

or declare the specific modules that [`makedocs`](@ref) should include with

```julia
makedocs(
    # options
    modules = [MyModule]
)
```


## Cross Referencing

It may be necessary to refer to a particular docstring or section of your document from
elsewhere in the document. To do this we can make use of Documenter's cross-referencing
syntax which looks pretty similar to normal markdown link syntax. Replace the contents of
`src/index.md` with the following

````markdown
# Example.jl Documentation

```@docs
greet(x)
```

- link to [Example.jl Documentation](@ref)
- link to [`greet(x)`](@ref)
````

So we just have to replace each link's url with `@ref` and write the name of the thing we'd
link to cross-reference. For document headers it's just plain text that matches the name of
the header and for docstrings enclose the object in backticks.

This also works across different pages in the same way. Note that these sections and
docstrings must be unique within a document.


## Navigation

Documenter can auto-generate tables of contents and docstring indexes for your document with
the following syntax. We'll illustrate these features using our `index.md` file from the
previous sections. Add the following to that file

````markdown
# Example.jl Documentation

```@contents
```

## Functions

```@docs
greet(x)
```

## Index

```@index
```
````

The `@contents` block will generate a nested list of links to all the section headers in
the document. By default it will gather all the level 1 and 2 headers from every page in the
document, but this can be adjusted using `Pages` and `Depth` settings as in the following

````markdown
```@contents
Pages = ["foo.md", "bar.md"]
Depth = 3
```
````

The `@index` block will generate a flat list of links to all the docs that that have been
spliced into the document using `@docs` blocks. As with the `@contents` block the pages to
be included can be set with a `Pages = [...]` line. Since the list is not nested `Depth` is
not supported for `@index`.


## Pages in the Sidebar

By default all the pages (`.md` files) in your source directory get added to the sidebar,
sorted by their filenames. However, in most cases you want to use the `pages` argument to
[`makedocs`](@ref) to control how the sidebar looks like. The basic usage is as follows:

```julia
makedocs(
    ...,
    pages = [
        "page.md",
        "Page title" => "page2.md",
        "Subsection" => [
            ...
        ]
    ]
)
```

Using the `pages` argument you can organize your pages into subsections and hide some pages
from the sidebar with the help of the [`hide`](@ref) functions.
