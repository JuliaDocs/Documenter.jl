{
    "docs": [
        {
            "location": "/", 
            "text": "Documenter.jl\n\n\nA documentation generator for Julia.\n\n\nA package for building documentation from docstrings and markdown files.\n\n\n\n\nNote\n\n\nPlease read through the \nDocumentation\n section of the main Julia manual if this is your first time using Julia's documentation system. Once you've read through how to write documentation for your code then come back here.\n\n\n\n\n\n\nPackage Features\n\n\n\n\nWrite all your documentation in \nMarkdown\n.\n\n\nMinimal configuration.\n\n\nSupports Julia \n0.4\n and \n0.5-dev\n.\n\n\nDoctests Julia code blocks.\n\n\nCross references for docs and section headers.\n\n\n$\\LaTeX$ syntax\n support.\n\n\nChecks for missing docstrings and incorrect cross references.\n\n\nGenerates tables of contents and docstring indexes.\n\n\nUse \ngit push\n to automatically build and deploy docs from Travis to GitHub Pages.\n\n\n\n\nThe \nPackage Guide\n provides a tutorial explaining how to get started using Documenter.\n\n\nSome examples of packages using Documenter can be found on the \nExamples\n page.\n\n\nSee the \nIndex\n for the complete list of documented functions and types.\n\n\n\n\nManual Outline\n\n\n\n\nPackage Guide\n\n\nExamples\n\n\nSyntax\n\n\nDoctests\n\n\nHosting Documentation\n\n\n$\\LaTeX$ syntax\n\n\nContributing\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nPublic Interface\n\n\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDocumenter\n\n\nDocumenter.Deps\n\n\nDocumenter.Travis\n\n\nDocumenter.Deps.pip\n\n\nDocumenter.Travis.genkeys\n\n\nDocumenter.deploydocs\n\n\nDocumenter.generate\n\n\nDocumenter.makedocs", 
            "title": "Home"
        }, 
        {
            "location": "/#documenterjl", 
            "text": "A documentation generator for Julia.  A package for building documentation from docstrings and markdown files.   Note  Please read through the  Documentation  section of the main Julia manual if this is your first time using Julia's documentation system. Once you've read through how to write documentation for your code then come back here.", 
            "title": "Documenter.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "Write all your documentation in  Markdown .  Minimal configuration.  Supports Julia  0.4  and  0.5-dev .  Doctests Julia code blocks.  Cross references for docs and section headers.  $\\LaTeX$ syntax  support.  Checks for missing docstrings and incorrect cross references.  Generates tables of contents and docstring indexes.  Use  git push  to automatically build and deploy docs from Travis to GitHub Pages.   The  Package Guide  provides a tutorial explaining how to get started using Documenter.  Some examples of packages using Documenter can be found on the  Examples  page.  See the  Index  for the complete list of documented functions and types.", 
            "title": "Package Features"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "Package Guide  Examples  Syntax  Doctests  Hosting Documentation  $\\LaTeX$ syntax  Contributing", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "Public Documentation  Contents  Index  Public Interface    Internal Documentation  Contents  Index", 
            "title": "Library Outline"
        }, 
        {
            "location": "/#index", 
            "text": "Documenter  Documenter.Deps  Documenter.Travis  Documenter.Deps.pip  Documenter.Travis.genkeys  Documenter.deploydocs  Documenter.generate  Documenter.makedocs", 
            "title": "Index"
        }, 
        {
            "location": "/man/guide/", 
            "text": "Package Guide\n\n\n\n\nInstallation\n\n\nDocumenter is a registered package and so can be installed via \nPkg.add\n.\n\n\nPkg\n.\nadd\n(\nDocumenter\n)\n\n\n\n\n\n\nThis package supports Julia \n0.4\n and \n0.5\n.\n\n\n\n\nUsage\n\n\nDocumenter is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.\n\n\n\n\nSetting up the folder structure\n\n\nFirstly, we need a Julia module to document. This could be a package generated via \nPkgDev.generate\n or a single \n.jl\n script. For this guide we'll be using a package called \nExample.jl\n that has the following directory layout:\n\n\nExample/\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nNote that the \n...\n just represent unimportant files and folders.\n\n\nWe must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named \ndocs/\n in the toplevel of the package, like so\n\n\nExample/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nInside the \ndocs/\n folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended\n\n\ndocs/\n    src/\n    make.jl\n\n\n\n\n\n\n\nBuilding an empty document\n\n\nWith our \ndocs/\n directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.\n\n\nAdd the following to your \nmake.jl\n file\n\n\nusing\n \nDocumenter\n,\n \nExample\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nThis assumes you've installed Documenter as discussed in \nInstallation\n and that your Examples package can be found by Julia.\n\n\nNow add an \nindex.md\n file to the \nsrc/\n directory. The name has no particular significance though and you may name it whatever you like. We'll stick to \nindex.md\n for this guide.\n\n\nLeave the newly added file empty and then run the following command from the \ndocs/\n directory\n\n\n$ julia make.jl\n\n\n\n\n\nNote that \n$\n just represents the prompt character. You don't need to type that.\n\n\nIf you'd like to see the output from this command in color use\n\n\n$ julia --color\n=\nyes make.jl\n\n\n\n\n\nWhen you run that you should see the following output\n\n\nDocumenter\n:\n \nsetting\n \nup\n \nbuild\n \ndirectory\n.\n\n\nDocumenter\n:\n \nexpanding\n \nmarkdown\n \ntemplates\n.\n\n\nDocumenter\n:\n \nbuilding\n \ncross\n-\nreferences\n.\n\n\nDocumenter\n:\n \nrunning\n \ndocument\n \nchecks\n.\n\n\nDocumenter\n:\n \nrendering\n \ndocument\n.\n\n\nDocumenter\n:\n \npopulating\n \nindices\n.\n\n\nDocumenter\n:\n \ncopying\n \nassets\n \nto\n \nbuild\n \ndirectory\n.\n\n\n\n\n\n\nThe \ndocs/\n folder should contain a new directory \u2013 called \nbuild/\n. It's structure should look like the following\n\n\nbuild/\n    assets/\n        Documenter.css\n        mathjaxhelper.js\n    index.md\n\n\n\n\n\nAt the moment \nbuild/index.md\n should be empty since \nsrc/index.md\n is empty.\n\n\nAt this point you can add some text to \nsrc/index.md\n and rerun the \nmake.jl\n file to see the changes if you'd like to.\n\n\n\n\nAdding some docstrings\n\n\nNext we'll splice a docstring defined in the \nExample\n module into the \nindex.md\n file. To do this first document a function in that module:\n\n\nmodule\n \nExample\n\n\n\nexport\n \nfunc\n\n\n\n\n\n    func(x)\n\n\n\nReturns double the number `x` plus `1`.\n\n\n\n\nfunc\n(\nx\n)\n \n=\n \n2\nx\n \n+\n \n1\n\n\n\nend\n\n\n\n\n\n\nThen in the \nsrc/index.md\n file add the following\n\n\n# Example.jl Documentation\n\n```@docs\nfunc(x)\n```\n\n\n\n\n\nWhen we next run \nmake.jl\n the docstring for \nExample.func(x)\n should appear in place of the \n@docs\n block in \nbuild/index.md\n. Note that \nmore than one\n object can be referenced inside a \n@docs\n block \u2013 just place each one on a separate line.\n\n\nNote that the module in which a \n@docs\n block is evaluated is determined by \ncurrent_module()\n and so will more than likely be \nMain\n. This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a \n@meta\n block as in the following\n\n\n# Example.jl Documentation\n\n```@meta\nCurrentModule = Documenter\n```\n\n```@docs\nfunc(x)\n```\n\n\n\n\n\n\n\nFiltering Included Docstrings\n\n\nIn some cases you may want to include a docstring for a \nMethod\n that extends a \nFunction\n from a different module \u2013 such as \nBase\n. In the following example we extend \nBase.length\n with a new definition for type \nT\n and also add a docstring:\n\n\ntype\n T\n\n    \n# ...\n\n\nend\n\n\n\n\n\nCustom `length` docs for `T`.\n\n\n\n\nBase\n.\nlength\n(::\nT\n)\n \n=\n \n1\n\n\n\n\n\n\nWhen trying to include this docstring with\n\n\n```@docs\nlength\n```\n\n\n\n\n\nall the docs for \nlength\n will be included \u2013 even those from other modules. There are two ways to solve this problem. Either include the type in the signature with\n\n\n```@docs\nlength(::T)\n```\n\n\n\n\n\nor declare the specific modules that \nmakedocs\n should include with\n\n\nmakedocs\n(\n\n    \n# options\n\n    \nmodules\n \n=\n \n[\nMyModule\n]\n\n\n)\n\n\n\n\n\n\n\n\nCross Referencing\n\n\nIt may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Documenter's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of \nsrc/index.md\n with the following\n\n\n# Example.jl Documentation\n\n```@docs\nfunc(x)\n```\n\n- link to [Example.jl Documentation](@ref)\n- link to [`func(x)`](@ref)\n\n\n\n\n\nSo we just have to replace each link's url with \n@ref\n and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.\n\n\nThis also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.\n\n\n\n\nNavigation\n\n\nDocumenter can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our \nindex.md\n file from the previous sections. Add the following to that file\n\n\n# Example.jl Documentation\n\n```@contents\n```\n\n## Functions\n\n```@docs\nfunc(x)\n```\n\n## Index\n\n```@index\n```\n\n\n\n\n\nThe \n@contents\n block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using \nPages\n and \nDepth\n settings as in the following\n\n\n```@contents\nPages = [\nfoo.md\n, \nbar.md\n]\nDepth = 3\n```\n\n\n\n\n\nThe \n@index\n block will generate a flat list of links to all the docs that that have been spliced into the document using \n@docs\n blocks. As with the \n@contents\n block the pages to be included can be set with a \nPages = [...]\n line. Since the list is not nested \nDepth\n is not supported for \n@index\n.", 
            "title": "Guide"
        }, 
        {
            "location": "/man/guide/#package-guide", 
            "text": "", 
            "title": "Package Guide"
        }, 
        {
            "location": "/man/guide/#installation", 
            "text": "Documenter is a registered package and so can be installed via  Pkg.add .  Pkg . add ( Documenter )   This package supports Julia  0.4  and  0.5 .", 
            "title": "Installation"
        }, 
        {
            "location": "/man/guide/#usage", 
            "text": "Documenter is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.", 
            "title": "Usage"
        }, 
        {
            "location": "/man/guide/#setting-up-the-folder-structure", 
            "text": "Firstly, we need a Julia module to document. This could be a package generated via  PkgDev.generate  or a single  .jl  script. For this guide we'll be using a package called  Example.jl  that has the following directory layout:  Example/\n    src/\n        Example.jl\n    ...  Note that the  ...  just represent unimportant files and folders.  We must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named  docs/  in the toplevel of the package, like so  Example/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...  Inside the  docs/  folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended  docs/\n    src/\n    make.jl", 
            "title": "Setting up the folder structure"
        }, 
        {
            "location": "/man/guide/#building-an-empty-document", 
            "text": "With our  docs/  directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.  Add the following to your  make.jl  file  using   Documenter ,   Example  makedocs ()   This assumes you've installed Documenter as discussed in  Installation  and that your Examples package can be found by Julia.  Now add an  index.md  file to the  src/  directory. The name has no particular significance though and you may name it whatever you like. We'll stick to  index.md  for this guide.  Leave the newly added file empty and then run the following command from the  docs/  directory  $ julia make.jl  Note that  $  just represents the prompt character. You don't need to type that.  If you'd like to see the output from this command in color use  $ julia --color = yes make.jl  When you run that you should see the following output  Documenter :   setting   up   build   directory .  Documenter :   expanding   markdown   templates .  Documenter :   building   cross - references .  Documenter :   running   document   checks .  Documenter :   rendering   document .  Documenter :   populating   indices .  Documenter :   copying   assets   to   build   directory .   The  docs/  folder should contain a new directory \u2013 called  build/ . It's structure should look like the following  build/\n    assets/\n        Documenter.css\n        mathjaxhelper.js\n    index.md  At the moment  build/index.md  should be empty since  src/index.md  is empty.  At this point you can add some text to  src/index.md  and rerun the  make.jl  file to see the changes if you'd like to.", 
            "title": "Building an empty document"
        }, 
        {
            "location": "/man/guide/#adding-some-docstrings", 
            "text": "Next we'll splice a docstring defined in the  Example  module into the  index.md  file. To do this first document a function in that module:  module   Example  export   func       func(x)  Returns double the number `x` plus `1`.   func ( x )   =   2 x   +   1  end   Then in the  src/index.md  file add the following  # Example.jl Documentation\n\n```@docs\nfunc(x)\n```  When we next run  make.jl  the docstring for  Example.func(x)  should appear in place of the  @docs  block in  build/index.md . Note that  more than one  object can be referenced inside a  @docs  block \u2013 just place each one on a separate line.  Note that the module in which a  @docs  block is evaluated is determined by  current_module()  and so will more than likely be  Main . This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a  @meta  block as in the following  # Example.jl Documentation\n\n```@meta\nCurrentModule = Documenter\n```\n\n```@docs\nfunc(x)\n```", 
            "title": "Adding some docstrings"
        }, 
        {
            "location": "/man/guide/#filtering-included-docstrings", 
            "text": "In some cases you may want to include a docstring for a  Method  that extends a  Function  from a different module \u2013 such as  Base . In the following example we extend  Base.length  with a new definition for type  T  and also add a docstring:  type  T \n     # ...  end   Custom `length` docs for `T`.   Base . length (:: T )   =   1   When trying to include this docstring with  ```@docs\nlength\n```  all the docs for  length  will be included \u2013 even those from other modules. There are two ways to solve this problem. Either include the type in the signature with  ```@docs\nlength(::T)\n```  or declare the specific modules that  makedocs  should include with  makedocs ( \n     # options \n     modules   =   [ MyModule ]  )", 
            "title": "Filtering Included Docstrings"
        }, 
        {
            "location": "/man/guide/#cross-referencing", 
            "text": "It may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Documenter's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of  src/index.md  with the following  # Example.jl Documentation\n\n```@docs\nfunc(x)\n```\n\n- link to [Example.jl Documentation](@ref)\n- link to [`func(x)`](@ref)  So we just have to replace each link's url with  @ref  and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.  This also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.", 
            "title": "Cross Referencing"
        }, 
        {
            "location": "/man/guide/#navigation", 
            "text": "Documenter can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our  index.md  file from the previous sections. Add the following to that file  # Example.jl Documentation\n\n```@contents\n```\n\n## Functions\n\n```@docs\nfunc(x)\n```\n\n## Index\n\n```@index\n```  The  @contents  block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using  Pages  and  Depth  settings as in the following  ```@contents\nPages = [ foo.md ,  bar.md ]\nDepth = 3\n```  The  @index  block will generate a flat list of links to all the docs that that have been spliced into the document using  @docs  blocks. As with the  @contents  block the pages to be included can be set with a  Pages = [...]  line. Since the list is not nested  Depth  is not supported for  @index .", 
            "title": "Navigation"
        }, 
        {
            "location": "/man/examples/", 
            "text": "Examples\n\n\nSometimes the best way to learn how to use a new package is to look for examples of what others have already built with it.\n\n\nThe following packages use Documenter to build their documentation and so should give a good overview of what this package is currently able to do.\n\n\n\n\nNote\n\n\nPackages are listed alphabetically. If you have a package that uses Documenter then please open a PR that adds it to the appropriate list below.\n\n\nThe \nmake.jl\n file for all listed packages will be tested to check for potential regressions prior to tagging new Documenter releases whenever possible.\n\n\n\n\n\n\nRegistered\n\n\nPackages that have tagged versions available in \nMETADATA.jl\n.\n\n\n\n\nControlSystems.jl\n\n\nCurrencies.jl\n\n\nDifferentialEquations.jl\n\n\nDocumenter.jl\n\n\nExtractMacro.jl\n\n\nMergedMethods.jl\n\n\nNumericSuffixes.jl\n\n\nOptim.jl\n\n\nPhyloNetworks.jl\n\n\nPOMDPs.jl\n\n\nPrivateModules.jl\n\n\nTaylorSeries.jl\n\n\nWeave.jl\n\n\n\n\n\n\nUnregistered\n\n\nPackages that are not available in \nMETADATA.jl\n and may be works-in-progress. Please do take that into consideration when browsing this list.\n\n\n\n\nAnonymousTypes.jl", 
            "title": "Examples"
        }, 
        {
            "location": "/man/examples/#examples", 
            "text": "Sometimes the best way to learn how to use a new package is to look for examples of what others have already built with it.  The following packages use Documenter to build their documentation and so should give a good overview of what this package is currently able to do.   Note  Packages are listed alphabetically. If you have a package that uses Documenter then please open a PR that adds it to the appropriate list below.  The  make.jl  file for all listed packages will be tested to check for potential regressions prior to tagging new Documenter releases whenever possible.", 
            "title": "Examples"
        }, 
        {
            "location": "/man/examples/#registered", 
            "text": "Packages that have tagged versions available in  METADATA.jl .   ControlSystems.jl  Currencies.jl  DifferentialEquations.jl  Documenter.jl  ExtractMacro.jl  MergedMethods.jl  NumericSuffixes.jl  Optim.jl  PhyloNetworks.jl  POMDPs.jl  PrivateModules.jl  TaylorSeries.jl  Weave.jl", 
            "title": "Registered"
        }, 
        {
            "location": "/man/examples/#unregistered", 
            "text": "Packages that are not available in  METADATA.jl  and may be works-in-progress. Please do take that into consideration when browsing this list.   AnonymousTypes.jl", 
            "title": "Unregistered"
        }, 
        {
            "location": "/man/syntax/", 
            "text": "Syntax\n\n\nThis section of the manual describes the syntax used by Documenter to build documentation.\n\n\n\n\nSyntax\n\n\n@docs\n block\n\n\n@autodocs\n block\n\n\n@ref\n link\n\n\n@meta\n block\n\n\n@index\n block\n\n\n@contents\n block\n\n\n@example\n block\n\n\n@repl\n block\n\n\n@eval\n block\n\n\n\n\n\n\n\n\n\n\n@docs\n block\n\n\nSplice one or more docstrings into a document in place of the code block, i.e.\n\n\n```@docs\nDocumenter\nmakedocs\ndeploydocs\n```\n\n\n\n\n\nThis block type is evaluated within the \nCurrentModule\n module if defined, otherwise within \ncurrent_module()\n, and so each object listed in the block should be visible from that module. Undefined objects will raise warnings during documentation generation and cause the code block to be rendered in the final document unchanged.\n\n\nObjects may not be listed more than once within the document. When duplicate objects are detected an error will be raised and the build process will be terminated.\n\n\nTo ensure that all docstrings from a module are included in the final document the \nmodules\n keyword for \nmakedocs\n can be set to the desired module or modules, i.e.\n\n\nmakedocs\n(\n\n    \nmodules\n \n=\n \n[\nDocumenter\n],\n\n\n)\n\n\n\n\n\n\nwhich will cause any unlisted docstrings to raise warnings when \nmakedocs\n is called. If \nmodules\n is not defined then no warnings are printed, even if a document has missing docstrings.\n\n\n\n\n@autodocs\n block\n\n\nAutomatically splices all docstrings from the provided modules in place of the code block. This is equivalent to manually adding all the docstrings in a \n@docs\n block.\n\n\n```@\nautodocs\n\n\nModules\n \n=\n \n[\nFoo\n,\n \nBar\n]\n\n\nOrder\n   \n=\n \n[\n:\nfunction\n,\n \n:\ntype\n]\n\n\n```\n\n\n\n\n\n\nThe above \n@autodocs\n block adds all the docstrings found in modules \nFoo\n and \nBar\n that refer to functions or types to the document.\n\n\nEach module is added in order and so all docs from \nFoo\n will appear before those of \nBar\n. Possible values for the \nOrder\n vector are\n\n\n\n\n:module\n\n\n:constant\n\n\n:type\n\n\n:function\n\n\n:macro\n\n\n\n\nIf no \nOrder\n is provided then the order listed above is used.\n\n\nWhen a potential docstring is found in one of the listed modules, but does not match any value from \nOrder\n then it will be omitted from the document. Hence \nOrder\n acts as a basic filter as well as sorter.\n\n\nIn addition to \nOrder\n, a \nPages\n vector may be included in \n@autodocs\n to filter docstrings based on the source file in which they are defined:\n\n\n```@\nautodocs\n\n\nModules\n \n=\n \n[\nFoo\n]\n\n\nPages\n   \n=\n \n[\na.jl\n,\n \nb.jl\n]\n\n\n```\n\n\n\n\n\n\nIn the above example docstrings from module \nFoo\n found in source files that end in \na.jl\n and \nb.jl\n are included. The page order provided by \nPages\n is also used to sort the docstrings. Note that page matching is done using the end of the provided strings and so \na.jl\n will be matched by \nany\n source file that ends in \na.jl\n, i.e. \nsrc/a.jl\n or \nsrc/foo/a.jl\n.\n\n\nTo include only the exported names from the modules listed in \nModules\n use \nPrivate = false\n. In a similar way \nPublic = false\n can be used to only show the unexported names. By default both of these are set to \ntrue\n so that all names will be shown.\n\n\nFunctions\n \nexported\n \nfrom\n \n`\nFoo\n`\n:\n\n\n\n```@\nautodocs\n\n\nModules\n \n=\n \n[\nFoo\n]\n\n\nPrivate\n \n=\n \nfalse\n\n\nOrder\n \n=\n \n[\n:\nfunction\n]\n\n\n```\n\n\n\nPrivate\n \ntypes\n \nin\n \nmodule\n \n`\nFoo\n`\n:\n\n\n\n```@\nautodocs\n\n\nModules\n \n=\n \n[\nFoo\n]\n\n\nPublic\n \n=\n \nfalse\n\n\nOrder\n \n=\n \n[\n:\ntype\n]\n\n\n```\n\n\n\n\n\n\n\n\nNote\n\n\nWhen more complex sorting and filtering is needed then use \n@docs\n to define it explicitly.\n\n\n\n\n\n\n@ref\n link\n\n\nUsed in markdown links as the URL to tell Documenter to generate a cross-reference automatically. The text part of the link can be a docstring, header name, or GitHub PR/Issue number.\n\n\n# Syntax\n\n... [`makedocs`](@ref) ...\n\n# Functions\n\n```@docs\nmakedocs\n```\n\n... [Syntax](@ref) ...\n\n... [#42](@ref) ...\n\n\n\n\n\nPlain text in the \"text\" part of a link will either cross-reference a header, or, when it is a number preceded by a \n#\n, a GitHub issue/pull request. Text wrapped in backticks will cross-reference a docstring from a \n@docs\n block.\n\n\n@ref\ns may refer to docstrings or headers on different pages as well as the current page using the same syntax.\n\n\nNote that depending on what the \nCurrentModule\n is set to, a docstring \n@ref\n may need to be prefixed by the module which defines it.\n\n\nDuplicate Headers\n\n\nIn some cases a document may contain multiple headers with the same name, but on different pages or of different levels. To allow \n@ref\n to cross-reference a duplicate header it must be given a name as in the following example\n\n\n# [Header](@id my_custom_header_name)\n\n\n\n...\n\n\n\n## Header\n\n\n\n...\n \n[\nCustom\n \nHeader\n](@\nref\n \nmy_custom_header_name\n)\n \n...\n\n\n\n\n\n\nThe link that wraps the named header is removed in the final document. The text for a named \n@ref ...\n does not need to match the header that it references. Named \n@ref ...\ns may refer to headers on different pages in the same way as unnamed ones do.\n\n\nDuplicate docstring references do not occur since splicing the same docstring into a document more than once is disallowed.\n\n\n\n\n@meta\n block\n\n\nThis block type is used to define metadata key/value pairs that can be used elsewhere in the page. Currently \nCurrentModule\n and \nDocTestSetup\n are the only recognised keys.\n\n\n```@meta\nCurrentModule = FooBar\nDocTestSetup  = quote\n    using MyPackage\nend\n```\n\n\n\n\n\nNote that \n@meta\n blocks are always evaluated with the \ncurrent_module()\n, which is typically \nMain\n.\n\n\nSee \nSetup Code\n section of the Doctests page for an explanation of \nDocTestSetup\n.\n\n\n\n\n@index\n block\n\n\nGenerates a list of links to docstrings that have been spliced into a document. Valid settings are \nPages\n, \nModules\n, and \nOrder\n. For example:\n\n\n```@\nindex\n\n\nPages\n   \n=\n \n[\nfoo.md\n]\n\n\nModules\n \n=\n \n[\nFoo\n,\n \nBar\n]\n\n\nOrder\n   \n=\n \n[\n:\nfunction\n,\n \n:\ntype\n]\n\n\n```\n\n\n\n\n\n\nWhen \nPages\n or \nModules\n are not provided then all pages or modules are included. \nOrder\n defaults to\n\n\n[:\nmodule\n,\n \n:\nconstant\n,\n \n:\ntype\n,\n \n:\nfunction\n,\n \n:\nmacro\n]\n\n\n\n\n\n\nif not specified. \nOrder\n and \nModules\n behave the same way as in \n@autodocs\n block\ns and filter out docstrings that do not match one of the modules or categories specified.\n\n\nNote that the values assigned to \nPages\n, \nModules\n, and \nOrder\n may be any valid Julia code and thus can be something more complex that an array literal if required, i.e.\n\n\n```@index\nPages = map(file -\n joinpath(\nman\n, file), readdir(\nman\n))\n```\n\n\n\n\n\nIt should be noted though that in this case \nPages\n may not be sorted in the order that is expected by the user. Try to stick to array literals as much as possible.\n\n\n\n\n@contents\n block\n\n\nGenerates a nested list of links to document sections. Valid settings are \nPages\n and \nDepth\n.\n\n\n```@contents\nPages = [\nfoo.md\n]\nDepth = 5\n```\n\n\n\n\n\nAs with \n@index\n if \nPages\n is not provided then all pages are included. The default \nDepth\n value is \n2\n.\n\n\n\n\n@example\n block\n\n\nEvaluates the code block and inserts the result into the final document along with the original source code.\n\n\n```@example\na = 1\nb = 2\na + b\n```\n\n\n\n\n\nThe above \n@example\n block will splice the following into the final document\n\n\n```julia\na = 1\nb = 2\na + b\n```\n\n```\n3\n```\n\n\n\n\n\nLeading and trailing newlines are removed from the rendered code blocks. Trailing whitespace on each line is also removed.\n\n\nHiding Source Code\n\n\nCode blocks may have some content that does not need to be displayed in the final document. \n# hide\n comments can be appended to lines that should not be rendered, i.e.\n\n\n```@example\nsrand(1) # hide\nA = rand(3, 3)\nb = [1, 2, 3]\nA \\ b\n```\n\n\n\n\n\nNote that appending \n# hide\n to every line in an \n@example\n block will result in the block being hidden in the rendered document. The results block will still be rendered though.\n\n\nSTDOUT\n and \nSTDERR\n\n\nThe Julia output streams are redirected to the results block when evaluating \n@example\n blocks in the same way as when running doctest code blocks.\n\n\nnothing\n Results\n\n\nWhen the \n@example\n block evaluates to \nnothing\n then the second block is not displayed. Only the source code block will be shown in the rendered document. Note that if any output from either \nSTDOUT\n or \nSTDERR\n is captured then the results block will be displayed even if \nnothing\n is returned.\n\n\nNamed \n@example\n Blocks\n\n\nBy default \n@example\n blocks are run in their own anonymous \nModule\ns to avoid side-effects between blocks. To share the same module between different blocks on a page the \n@example\n can be named with the following syntax\n\n\n```@example 1\na = 1\n```\n\n```@example 1\nprintln(a)\n```\n\n\n\n\n\nThe name can be any text, not just integers as in the example above, i.e. \n@example foo\n.\n\n\nNamed \n@example\n blocks can be useful when generating documentation that requires intermediate explanation or multimedia such as plots as illustrated in the following example\n\n\nFirst we define some functions\n\n```@example 1\nusing PyPlot # hide\nf(x) = sin(2x) + 1\ng(x) = cos(x) - x\n```\n\nand then we plot `f` over the interval from ``-\u03c0`` to ``\u03c0``\n\n```@example 1\nx = linspace(-\u03c0, \u03c0)\nplot(x, f(x), color = \nred\n)\nsavefig(\nf-plot.svg\n); nothing # hide\n```\n\n![](f-plot.svg)\n\nand then we do the same with `g`\n\n```@example 1\nplot(x, g(x), color = \nblue\n)\nsavefig(\ng-plot.svg\n); nothing # hide\n```\n\n![](g-plot.svg)\n\n\n\n\n\nNote that \n@example\n blocks are evaluated within the directory of \nbuild\n where the file will be rendered . This means than in the above example \nsavefig\n will output the \n.svg\n files into that directory. This allows the images to be easily referenced without needing to worry about relative paths.\n\n\n@example\n blocks automatically define \nans\n which, as in the Julia REPL, is bound to the value of the last evaluated expression. This can be useful in situations such as the following one where where binding the object returned by \nplot\n to a named variable would look out of place in the final rendered documentation:\n\n\n```@example\nusing Gadfly # hide\nplot([sin, x -\n 2sin(x) + x], -2\u03c0, 2\u03c0)\ndraw(SVG(\nplot.svg\n, 6inch, 4inch), ans); nothing # hide\n```\n\n![](plot.svg)\n\n\n\n\n\n\n\n@repl\n block\n\n\nThese are similar to \n@example\n blocks, but adds a \njulia\n prompt before each toplevel expression. \n;\n and \n# hide\n syntax may be used in \n@repl\n blocks in the same way as in the Julia REPL and \n@example\n blocks.\n\n\n```@repl\na = 1\nb = 2\na + b\n```\n\n\n\n\n\nwill generate\n\n\n```julia\njulia\n a = 1\n1\n\njulia\n b = 2\n2\n\njulia\n a + b\n3\n```\n\n\n\n\n\nNamed \n@repl \nname\n blocks behave in the same way as named \n@example \nname\n blocks.\n\n\n\n\n@eval\n block\n\n\nEvaluates the contents of the block and inserts the resulting value into the final document.\n\n\nIn the following example we use the PyPlot package to generate a plot and display it in the final document.\n\n\n```@eval\nusing PyPlot\n\nx = linspace(-\u03c0, \u03c0)\ny = sin(x)\n\nplot(x, y, color = \nred\n)\nsavefig(\nplot.svg\n)\n\nnothing\n```\n\n![](plot.svg)\n\n\n\n\n\nNote that each \n@eval\n block evaluates its contents within a separate module. When evaluating each block the present working directory, \npwd\n, is set to the directory in \nbuild\n where the file will be written to.\n\n\nAlso, instead of returning \nnothing\n in the example above we could have returned a new \nMarkdown.MD\n object through \nMarkdown.parse\n. This can be more appropriate when the  filename is not known until evaluation of the block itself.\n\n\n\n\nNote\n\n\nIn most cases \n@example\n is preferred over \n@eval\n. Just like in normal Julia code where \neval\n should be only be considered as a last resort, \n@eval\n should be treated in the same way.", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/syntax/#syntax", 
            "text": "This section of the manual describes the syntax used by Documenter to build documentation.   Syntax  @docs  block  @autodocs  block  @ref  link  @meta  block  @index  block  @contents  block  @example  block  @repl  block  @eval  block", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/syntax/#docs-block", 
            "text": "Splice one or more docstrings into a document in place of the code block, i.e.  ```@docs\nDocumenter\nmakedocs\ndeploydocs\n```  This block type is evaluated within the  CurrentModule  module if defined, otherwise within  current_module() , and so each object listed in the block should be visible from that module. Undefined objects will raise warnings during documentation generation and cause the code block to be rendered in the final document unchanged.  Objects may not be listed more than once within the document. When duplicate objects are detected an error will be raised and the build process will be terminated.  To ensure that all docstrings from a module are included in the final document the  modules  keyword for  makedocs  can be set to the desired module or modules, i.e.  makedocs ( \n     modules   =   [ Documenter ],  )   which will cause any unlisted docstrings to raise warnings when  makedocs  is called. If  modules  is not defined then no warnings are printed, even if a document has missing docstrings.", 
            "title": "@docs block"
        }, 
        {
            "location": "/man/syntax/#autodocs-block", 
            "text": "Automatically splices all docstrings from the provided modules in place of the code block. This is equivalent to manually adding all the docstrings in a  @docs  block.  ```@ autodocs  Modules   =   [ Foo ,   Bar ]  Order     =   [ : function ,   : type ]  ```   The above  @autodocs  block adds all the docstrings found in modules  Foo  and  Bar  that refer to functions or types to the document.  Each module is added in order and so all docs from  Foo  will appear before those of  Bar . Possible values for the  Order  vector are   :module  :constant  :type  :function  :macro   If no  Order  is provided then the order listed above is used.  When a potential docstring is found in one of the listed modules, but does not match any value from  Order  then it will be omitted from the document. Hence  Order  acts as a basic filter as well as sorter.  In addition to  Order , a  Pages  vector may be included in  @autodocs  to filter docstrings based on the source file in which they are defined:  ```@ autodocs  Modules   =   [ Foo ]  Pages     =   [ a.jl ,   b.jl ]  ```   In the above example docstrings from module  Foo  found in source files that end in  a.jl  and  b.jl  are included. The page order provided by  Pages  is also used to sort the docstrings. Note that page matching is done using the end of the provided strings and so  a.jl  will be matched by  any  source file that ends in  a.jl , i.e.  src/a.jl  or  src/foo/a.jl .  To include only the exported names from the modules listed in  Modules  use  Private = false . In a similar way  Public = false  can be used to only show the unexported names. By default both of these are set to  true  so that all names will be shown.  Functions   exported   from   ` Foo ` :  ```@ autodocs  Modules   =   [ Foo ]  Private   =   false  Order   =   [ : function ]  ```  Private   types   in   module   ` Foo ` :  ```@ autodocs  Modules   =   [ Foo ]  Public   =   false  Order   =   [ : type ]  ```    Note  When more complex sorting and filtering is needed then use  @docs  to define it explicitly.", 
            "title": "@autodocs block"
        }, 
        {
            "location": "/man/syntax/#ref-link", 
            "text": "Used in markdown links as the URL to tell Documenter to generate a cross-reference automatically. The text part of the link can be a docstring, header name, or GitHub PR/Issue number.  # Syntax\n\n... [`makedocs`](@ref) ...\n\n# Functions\n\n```@docs\nmakedocs\n```\n\n... [Syntax](@ref) ...\n\n... [#42](@ref) ...  Plain text in the \"text\" part of a link will either cross-reference a header, or, when it is a number preceded by a  # , a GitHub issue/pull request. Text wrapped in backticks will cross-reference a docstring from a  @docs  block.  @ref s may refer to docstrings or headers on different pages as well as the current page using the same syntax.  Note that depending on what the  CurrentModule  is set to, a docstring  @ref  may need to be prefixed by the module which defines it.  Duplicate Headers  In some cases a document may contain multiple headers with the same name, but on different pages or of different levels. To allow  @ref  to cross-reference a duplicate header it must be given a name as in the following example  # [Header](@id my_custom_header_name)  ...  ## Header  ...   [ Custom   Header ](@ ref   my_custom_header_name )   ...   The link that wraps the named header is removed in the final document. The text for a named  @ref ...  does not need to match the header that it references. Named  @ref ... s may refer to headers on different pages in the same way as unnamed ones do.  Duplicate docstring references do not occur since splicing the same docstring into a document more than once is disallowed.", 
            "title": "@ref link"
        }, 
        {
            "location": "/man/syntax/#meta-block", 
            "text": "This block type is used to define metadata key/value pairs that can be used elsewhere in the page. Currently  CurrentModule  and  DocTestSetup  are the only recognised keys.  ```@meta\nCurrentModule = FooBar\nDocTestSetup  = quote\n    using MyPackage\nend\n```  Note that  @meta  blocks are always evaluated with the  current_module() , which is typically  Main .  See  Setup Code  section of the Doctests page for an explanation of  DocTestSetup .", 
            "title": "@meta block"
        }, 
        {
            "location": "/man/syntax/#index-block", 
            "text": "Generates a list of links to docstrings that have been spliced into a document. Valid settings are  Pages ,  Modules , and  Order . For example:  ```@ index  Pages     =   [ foo.md ]  Modules   =   [ Foo ,   Bar ]  Order     =   [ : function ,   : type ]  ```   When  Pages  or  Modules  are not provided then all pages or modules are included.  Order  defaults to  [: module ,   : constant ,   : type ,   : function ,   : macro ]   if not specified.  Order  and  Modules  behave the same way as in  @autodocs  block s and filter out docstrings that do not match one of the modules or categories specified.  Note that the values assigned to  Pages ,  Modules , and  Order  may be any valid Julia code and thus can be something more complex that an array literal if required, i.e.  ```@index\nPages = map(file -  joinpath( man , file), readdir( man ))\n```  It should be noted though that in this case  Pages  may not be sorted in the order that is expected by the user. Try to stick to array literals as much as possible.", 
            "title": "@index block"
        }, 
        {
            "location": "/man/syntax/#contents-block", 
            "text": "Generates a nested list of links to document sections. Valid settings are  Pages  and  Depth .  ```@contents\nPages = [ foo.md ]\nDepth = 5\n```  As with  @index  if  Pages  is not provided then all pages are included. The default  Depth  value is  2 .", 
            "title": "@contents block"
        }, 
        {
            "location": "/man/syntax/#example-block", 
            "text": "Evaluates the code block and inserts the result into the final document along with the original source code.  ```@example\na = 1\nb = 2\na + b\n```  The above  @example  block will splice the following into the final document  ```julia\na = 1\nb = 2\na + b\n```\n\n```\n3\n```  Leading and trailing newlines are removed from the rendered code blocks. Trailing whitespace on each line is also removed.  Hiding Source Code  Code blocks may have some content that does not need to be displayed in the final document.  # hide  comments can be appended to lines that should not be rendered, i.e.  ```@example\nsrand(1) # hide\nA = rand(3, 3)\nb = [1, 2, 3]\nA \\ b\n```  Note that appending  # hide  to every line in an  @example  block will result in the block being hidden in the rendered document. The results block will still be rendered though.  STDOUT  and  STDERR  The Julia output streams are redirected to the results block when evaluating  @example  blocks in the same way as when running doctest code blocks.  nothing  Results  When the  @example  block evaluates to  nothing  then the second block is not displayed. Only the source code block will be shown in the rendered document. Note that if any output from either  STDOUT  or  STDERR  is captured then the results block will be displayed even if  nothing  is returned.  Named  @example  Blocks  By default  @example  blocks are run in their own anonymous  Module s to avoid side-effects between blocks. To share the same module between different blocks on a page the  @example  can be named with the following syntax  ```@example 1\na = 1\n```\n\n```@example 1\nprintln(a)\n```  The name can be any text, not just integers as in the example above, i.e.  @example foo .  Named  @example  blocks can be useful when generating documentation that requires intermediate explanation or multimedia such as plots as illustrated in the following example  First we define some functions\n\n```@example 1\nusing PyPlot # hide\nf(x) = sin(2x) + 1\ng(x) = cos(x) - x\n```\n\nand then we plot `f` over the interval from ``-\u03c0`` to ``\u03c0``\n\n```@example 1\nx = linspace(-\u03c0, \u03c0)\nplot(x, f(x), color =  red )\nsavefig( f-plot.svg ); nothing # hide\n```\n\n![](f-plot.svg)\n\nand then we do the same with `g`\n\n```@example 1\nplot(x, g(x), color =  blue )\nsavefig( g-plot.svg ); nothing # hide\n```\n\n![](g-plot.svg)  Note that  @example  blocks are evaluated within the directory of  build  where the file will be rendered . This means than in the above example  savefig  will output the  .svg  files into that directory. This allows the images to be easily referenced without needing to worry about relative paths.  @example  blocks automatically define  ans  which, as in the Julia REPL, is bound to the value of the last evaluated expression. This can be useful in situations such as the following one where where binding the object returned by  plot  to a named variable would look out of place in the final rendered documentation:  ```@example\nusing Gadfly # hide\nplot([sin, x -  2sin(x) + x], -2\u03c0, 2\u03c0)\ndraw(SVG( plot.svg , 6inch, 4inch), ans); nothing # hide\n```\n\n![](plot.svg)", 
            "title": "@example block"
        }, 
        {
            "location": "/man/syntax/#repl-block", 
            "text": "These are similar to  @example  blocks, but adds a  julia  prompt before each toplevel expression.  ;  and  # hide  syntax may be used in  @repl  blocks in the same way as in the Julia REPL and  @example  blocks.  ```@repl\na = 1\nb = 2\na + b\n```  will generate  ```julia\njulia  a = 1\n1\n\njulia  b = 2\n2\n\njulia  a + b\n3\n```  Named  @repl  name  blocks behave in the same way as named  @example  name  blocks.", 
            "title": "@repl block"
        }, 
        {
            "location": "/man/syntax/#eval-block", 
            "text": "Evaluates the contents of the block and inserts the resulting value into the final document.  In the following example we use the PyPlot package to generate a plot and display it in the final document.  ```@eval\nusing PyPlot\n\nx = linspace(-\u03c0, \u03c0)\ny = sin(x)\n\nplot(x, y, color =  red )\nsavefig( plot.svg )\n\nnothing\n```\n\n![](plot.svg)  Note that each  @eval  block evaluates its contents within a separate module. When evaluating each block the present working directory,  pwd , is set to the directory in  build  where the file will be written to.  Also, instead of returning  nothing  in the example above we could have returned a new  Markdown.MD  object through  Markdown.parse . This can be more appropriate when the  filename is not known until evaluation of the block itself.   Note  In most cases  @example  is preferred over  @eval . Just like in normal Julia code where  eval  should be only be considered as a last resort,  @eval  should be treated in the same way.", 
            "title": "@eval block"
        }, 
        {
            "location": "/man/doctests/", 
            "text": "Doctests\n\n\nDocumenter will, by default, try to run \njldoctest\n code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Documenter's doctest.\n\n\nThis section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.\n\n\n\n\n\"Script\" Examples\n\n\nThe first, of two, types of doctests is the \"script\" code block. To make Documenter detect this kind of code block the following format must be used:\n\n\n```jldoctest\na = 1\nb = 2\na + b\n\n# output\n\n3\n```\n\n\n\n\n\nThe code block's \"language\" must be \njldoctest\n and must include a line containing the text \n# output\n. The text before this line is the contents of the script which is run. The text that appears after \n# output\n is the textual representation that would be shown in the Julia REPL if the script had been \ninclude\nd.\n\n\nThe actual output produced by running the \"script\" is compared to the expected result and any difference will result in \nmakedocs\n throwing an error and terminating.\n\n\nNote that the amount of whitespace appearing above and below the \n# output\n line is not significant and can be increased or decreased if desired.\n\n\n\n\nREPL Examples\n\n\nThe other kind of doctest is a simulated Julia REPL session. The following format is detected by Documenter as a REPL doctest:\n\n\n```jldoctest\njulia\n a = 1\n1\n\njulia\n b = 2;\n\njulia\n c = 3;  # comment\n\njulia\n a + b + c\n6\n\n```\n\n\n\n\n\nAs with script doctests, the code block must have it's language set to \njldoctest\n. When a code block contains one or more \njulia\n at the start of a line then it is assumed to be a REPL doctest. Semi-colons, \n;\n, at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.\n\n\nNote that not all features of the REPL are supported such as shell and help modes.\n\n\n\n\nExceptions\n\n\nDoctests can also test for thrown exceptions and their stacktraces. Comparing of the actual and expected results is done by checking whether the expected result matches the start of the actual result. Hence, both of the following errors will match the actual result.\n\n\n```jldoctest\njulia\n div(1, 0)\nERROR: DivideError: integer division error\n in div(::Int64, ::Int64) at ./int.jl:115\n\njulia\n div(1, 0)\nERROR: DivideError: integer division error\n\n```\n\n\n\n\n\nIf instead the first \ndiv(1, 0)\n error was written as\n\n\n```jldoctest\njulia\n div(1, 0)\nERROR: DivideError: integer division error\n in div(::Int64, ::Int64) at ./int.jl:114\n\n```\n\n\n\n\n\nwhere line \n115\n is replaced with \n114\n then the doctest will fail.\n\n\nIn the second \ndiv(1, 0)\n, where no stacktrace is shown, it may appear to the reader that it is expected that no stacktrace will actually be displayed when they attempt to try to recreate the error themselves. To indicate to readers that the output result is truncated and does not display the entire (or any of) the stacktrace you may write \n[...]\n at the line where checking should stop, i.e.\n\n\n```jldoctest\njulia\n div(1, 0)\nERROR: DivideError: integer division error\n[...]\n\n```\n\n\n\n\n\n\n\nSkipping Doctests\n\n\nDoctesting can be disabled by setting the \nmakedocs\n keyword \ndoctest = false\n. This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.\n\n\n\n\nSetup Code\n\n\nDoctests may require some setup code that must be evaluated prior to that of the actual example, but that should not be displayed in the final documentation. It could also be that several separate doctests require the same definitions. For both of these cases a \n@meta\n block containing a \nDocTestSetup = ...\n value can be used as follows:\n\n\n```\njldoctest\n\n\njulia\n \nusing\n \nDataFrames\n\n\n\njulia\n \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n);\n\n\n\n```\n\n\n\nSome\n \ntext\n \ndiscussing\n \n`\ndf\n`\n...\n\n\n\n```\n@meta\n\n\nDocTestSetup\n \n=\n \nquote\n\n    \nusing\n \nDataFrames\n\n    \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n)\n\n\nend\n\n\n```\n\n\n\n```\njldoctest\n\n\njulia\n \ndf\n[\n1\n,\n \n1\n]\n\n\n1\n\n\n```\n\n\n\nSome\n \nmore\n \ntext\n...\n\n\n\n```\njldoctest\n\n\njulia\n \ndf\n[\n1\n,\n \n:\n]\n\n\n1x2\n \nDataFrames\n.DataFrame\n\n\n|\n \nRow\n \n|\n \nA\n \n|\n \nB\n \n|\n\n\n|\n-----\n|\n---\n|\n---\n|\n\n\n|\n \n1\n   \n|\n \n1\n \n|\n \n2\n \n|\n\n\n```\n\n\n\n```\n@meta\n\n\nDocTestSetup\n \n=\n \nnothing\n\n\n```\n\n\n\n\n\n\nNote that the \nDocTestSetup\n value is \nre-evaluated\n at the start of \neach\n doctest block and no state is shared between any code blocks. The \nDocTestSetup = nothing\n is not strictly necessary, but good practice nonetheless to help avoid unintentional definitions later on a page.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#doctests", 
            "text": "Documenter will, by default, try to run  jldoctest  code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Documenter's doctest.  This section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#script-examples", 
            "text": "The first, of two, types of doctests is the \"script\" code block. To make Documenter detect this kind of code block the following format must be used:  ```jldoctest\na = 1\nb = 2\na + b\n\n# output\n\n3\n```  The code block's \"language\" must be  jldoctest  and must include a line containing the text  # output . The text before this line is the contents of the script which is run. The text that appears after  # output  is the textual representation that would be shown in the Julia REPL if the script had been  include d.  The actual output produced by running the \"script\" is compared to the expected result and any difference will result in  makedocs  throwing an error and terminating.  Note that the amount of whitespace appearing above and below the  # output  line is not significant and can be increased or decreased if desired.", 
            "title": "\"Script\" Examples"
        }, 
        {
            "location": "/man/doctests/#repl-examples", 
            "text": "The other kind of doctest is a simulated Julia REPL session. The following format is detected by Documenter as a REPL doctest:  ```jldoctest\njulia  a = 1\n1\n\njulia  b = 2;\n\njulia  c = 3;  # comment\n\njulia  a + b + c\n6\n\n```  As with script doctests, the code block must have it's language set to  jldoctest . When a code block contains one or more  julia  at the start of a line then it is assumed to be a REPL doctest. Semi-colons,  ; , at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.  Note that not all features of the REPL are supported such as shell and help modes.", 
            "title": "REPL Examples"
        }, 
        {
            "location": "/man/doctests/#exceptions", 
            "text": "Doctests can also test for thrown exceptions and their stacktraces. Comparing of the actual and expected results is done by checking whether the expected result matches the start of the actual result. Hence, both of the following errors will match the actual result.  ```jldoctest\njulia  div(1, 0)\nERROR: DivideError: integer division error\n in div(::Int64, ::Int64) at ./int.jl:115\n\njulia  div(1, 0)\nERROR: DivideError: integer division error\n\n```  If instead the first  div(1, 0)  error was written as  ```jldoctest\njulia  div(1, 0)\nERROR: DivideError: integer division error\n in div(::Int64, ::Int64) at ./int.jl:114\n\n```  where line  115  is replaced with  114  then the doctest will fail.  In the second  div(1, 0) , where no stacktrace is shown, it may appear to the reader that it is expected that no stacktrace will actually be displayed when they attempt to try to recreate the error themselves. To indicate to readers that the output result is truncated and does not display the entire (or any of) the stacktrace you may write  [...]  at the line where checking should stop, i.e.  ```jldoctest\njulia  div(1, 0)\nERROR: DivideError: integer division error\n[...]\n\n```", 
            "title": "Exceptions"
        }, 
        {
            "location": "/man/doctests/#skipping-doctests", 
            "text": "Doctesting can be disabled by setting the  makedocs  keyword  doctest = false . This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.", 
            "title": "Skipping Doctests"
        }, 
        {
            "location": "/man/doctests/#setup-code", 
            "text": "Doctests may require some setup code that must be evaluated prior to that of the actual example, but that should not be displayed in the final documentation. It could also be that several separate doctests require the same definitions. For both of these cases a  @meta  block containing a  DocTestSetup = ...  value can be used as follows:  ``` jldoctest  julia   using   DataFrames  julia   df   =   DataFrame ( A   =   1 :10 ,   B   =   2 :2:20 );  ```  Some   text   discussing   ` df ` ...  ``` @meta  DocTestSetup   =   quote \n     using   DataFrames \n     df   =   DataFrame ( A   =   1 :10 ,   B   =   2 :2:20 )  end  ```  ``` jldoctest  julia   df [ 1 ,   1 ]  1  ```  Some   more   text ...  ``` jldoctest  julia   df [ 1 ,   : ]  1x2   DataFrames .DataFrame  |   Row   |   A   |   B   |  | ----- | --- | --- |  |   1     |   1   |   2   |  ```  ``` @meta  DocTestSetup   =   nothing  ```   Note that the  DocTestSetup  value is  re-evaluated  at the start of  each  doctest block and no state is shared between any code blocks. The  DocTestSetup = nothing  is not strictly necessary, but good practice nonetheless to help avoid unintentional definitions later on a page.", 
            "title": "Setup Code"
        }, 
        {
            "location": "/man/hosting/", 
            "text": "Hosting Documentation\n\n\nAfter going through the \nPackage Guide\n and \nDoctests\n page you will need to host the generated documentation somewhere for potential users to read. This guide will describe how to setup automatic updates for your package docs using the Travis build service and GitHub Pages. This is the same approach used by this package to host it's own docs \u2013 the docs you're currently reading.\n\n\n\n\nNote\n\n\nFollowing this guide should be the \nfinal\n step you take after you are comfortable with the syntax and build process used by \nDocumenter.jl\n. Only proceed with the steps outlined on this page once you have successfully used \nmkdocs\n locally to build your documentation.  \nmkdocs\n can typically be installed using \npip install mkdocs\n in your terminal.\n\n\nThis guide assumes that you already have GitHub and Travis accounts setup. If not then go set those up first and then return here.\n\n\n\n\n\n\nOverview\n\n\nOnce setup correctly the following will happen each time you push new updates to your package repository:\n\n\n\n\ntravis buildbots startup and run your tests;\n\n\neach buildbot will build the package docs using your \ndocs/make.jl\n script;\n\n\na single buildbot will then try to push the generated docs back to github.\n\n\n\n\nNote that the hosted documentation does not update when you make pull requests; you see updates only when you merge to \nmaster\n or push new tags.\n\n\nThe following sections outline how to enable this for your own package.\n\n\n\n\nDeploy Keys\n\n\nTwo methods are available for securely deploying generated documentation from Travis to GitHub. The first method listed below is the preferred approach. The second, and original, method should be avoided whenever possible.\n\n\n\n\nSSH Deploy Keys\n\n\nDeploy keys provide push access to a \nsingle\n repository.\n\n\n\n\nNote\n\n\nYou will need several command line programs installed for the following steps to work. They are \nwhich\n, \ngit\n, \nssh-keygen\n, and \ntravis\n.  Make sure these are installed before you begin.\n\n\n\n\nOpen a Julia REPL and import \nDocumenter\n.\n\n\njulia\n \nusing\n \nDocumenter\n\n\n\n\n\n\nThen call the \nTravis.genkeys\n function as follows:\n\n\njulia\n \nTravis\n.\ngenkeys\n(\nMyPackage\n)\n\n\n\n\n\n\nwhere \n\"MyPackage\"\n is the name of the package you would like to create deploy keys for.\n\n\nYou may be asked to enter your password for Travis during this process. Once complete you will need to add the public key displayed in the REPL to your repository \u2013 just follow the instructions displayed in the REPL. If you see a line about adding an \nopenssl\n command to your \n.travis.yml\n file, you can ignore that (Documenter will handle that for you).\n\n\nThen close the REPL and commit the \ndocs/.documenter.enc\n file that was generated by \nTravis.genkeys\n to the repository. You can skip the \nGitHub Security Tokens\n section and move straight on to \nTravis Environment Settings\n now.\n\n\nIf you don't get a \ndocs/.documenter.enc\n file, one possible reason is an outdated version of \ntravis\n. At the time of this writing, version 1.8.2 was known to work.\n\n\n\n\nGitHub Security Tokens\n\n\nThese tokens provide push access to \nevery\n repository owned by the user.\n\n\nFirstly, generate a new \npersonal access token\n.\n\n\nEnter a description for this new token. We'll be calling ours \"Travis\", but any other name will do. For the \"Select scopes\" option choose \"public_repo\" \nonly\n. Then generate the token and save it somewhere safe. We'll be needing it during the next section.\n\n\n\n\nTravis Environment Settings\n\n\n\n\nSSH Keys\n\n\nIf you used \nTravis.genkeys\n in the previous step then you should go to your Travis settings page and check that two new keys have been added with names similar to the following\n\n\n\n\nencrypted_e6b49e69746a_key\n\n\nencrypted_e6b49e69746a_iv\n\n\n\n\n\n\nTokens\n\n\nIf you generated a GitHub token during the previous step then we'll add the token to our repository's Travis page. Go to the settings page for the repository and under the \"Environment Variables\" section add a new variable called \nGITHUB_API_KEY\n. Copy the generated key from the \nGitHub Security Tokens\n section as the value and \nmake sure\n that \"Display value in build log\" is \noff\n. Be careful to remove any leading white-space from the key. Then add the key.\n\n\n\n\n.travis.yml\n Configuration\n\n\nIn the \nafter_success\n section of the \n.travis.yml\n file, where code coverage is processed, run your \ndocs/make.jl\n file:\n\n\nafter_success\n:\n\n  \n-\n \njulia -e \nPkg.add(\nDocumenter\n)\n\n  \n-\n \njulia -e \ncd(Pkg.dir(\nPACKAGE_NAME\n)); include(joinpath(\ndocs\n, \nmake.jl\n))\n\n\n\n\n\n\n\n\nThe \ndeploydocs\n Function\n\n\nAt the moment your \ndocs/make.jl\n file probably only contains\n\n\nusing\n \nDocumenter\n,\n \nPACKAGE_NAME\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nWe'll need to add an additional call to this file after \nmakedocs\n. Add the following at the end of the file:\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n\n\n)\n\n\n\n\n\n\nwhere \nUSER_NAME\n and \nPACKAGE_NAME\n must be set to the appropriate names.\n\n\nBy default \ndeploydocs\n will deploy the documentation from the \nnightly\n Julia build for Linux. This can be changed using the \njulia\n and \nosname\n keywords as follows:\n\n\ndeploydocs\n(\n\n    \ndeps\n   \n=\n \nDeps\n.\npip\n(\nmkdocs\n,\n \npython-markdown-math\n),\n\n    \nrepo\n   \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n,\n\n    \njulia\n  \n=\n \n0.4\n,\n\n    \nosname\n \n=\n \nosx\n\n\n)\n\n\n\n\n\n\nThis will deploy the docs from the OSX Julia 0.4 Travis build bot.\n\n\nThe keyword \ndeps\n serves to provide the required dependencies to deploy the documentation. In the example above we include the dependencies \nmkdocs\n and \npython-markdown-math\n. The former makes sure that MkDocs is installed to deploy the documentation, and the latter provides the \nmdx_math\n markdown extension to exploit MathJax rendering of latex equations in markdown. Other dependencies should be included here.\n\n\nSee the \ndeploydocs\n function documentation for more details.\n\n\n\n\nThe MkDocs \nmkdocs.yml\n File\n\n\nWe'll be using \nMkDocs\n to convert the markdown files generated by Documenter to HTML. (This, of course, is not the only option you have for this step. Any markdown to HTML converter should work fine with some amount of setting up.)\n\n\nAdd an \nmkdocs.yml\n file to your \ndocs/\n directory with the following content:\n\n\nsite_name\n:\n        \nPACKAGE_NAME.jl\n\n\nrepo_url\n:\n         \nhttps://github.com/USER_NAME/PACKAGE_NAME.jl\n\n\nsite_description\n:\n \nDescription...\n\n\nsite_author\n:\n      \nUSER_NAME\n\n\n\ntheme\n:\n \nreadthedocs\n\n\n\nextra_css\n:\n\n  \n-\n \nassets/Documenter.css\n\n\n\nextra_javascript\n:\n\n  \n-\n \nhttps://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\n\n  \n-\n \nassets/mathjaxhelper.js\n\n\n\nmarkdown_extensions\n:\n\n  \n-\n \nextra\n\n  \n-\n \ntables\n\n  \n-\n \nfenced_code\n\n  \n-\n \nmdx_math\n\n\n\ndocs_dir\n:\n \nbuild\n\n\n\npages\n:\n\n  \n-\n \nHome\n:\n \nindex.md\n\n\n\n\n\n\nThis is only a basic skeleton. Read through the MkDocs documentation if you would like to know more about the available settings.\n\n\n\n\n.gitignore\n\n\nAdd the following to your package's \n.gitignore\n file\n\n\ndocs/build/\ndocs/site/\n\n\n\n\n\nThese are needed to avoid committing generated content to your repository.\n\n\n\n\ngh-pages\n Branch\n\n\nCreate a new branch called \ngh-pages\n and push it to GitHub. If this branch already exists then you can skip this step, but do note that the generated content is automatically pushed to this branch from Travis.\n\n\n\n\nDocumentation Versions\n\n\nWhen documentation is generated it is stored in one of the following folders:\n\n\n\n\nlatest\n stores the most recent documentation that is committed to the \nmaster\n branch.\n\n\nstable\n stores the most recent documentation from a tagged commit. Older tagged versions are stored in directories named after their tags. These tagged directories are persistent and must be manually removed from the \ngh-pages\n branch if necessary.\n\n\n\n\nOnce your documentation has been pushed to the \ngh-pages\n branch you should add links to your \nREADME.md\n pointing to the \nstable\n and \nlatest\n documentation URLs. It is common practice to make use of \"badges\" similar to those used for Travis and AppVeyor build statuses or code coverage. Adding the following to your package \nREADME.md\n should be all that is necessary:\n\n\n[![](https://img.shields.io/badge/docs-stable-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/stable)\n[![](https://img.shields.io/badge/docs-latest-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/latest)\n\n\n\n\n\nPACKAGE_NAME\n and \nUSER_NAME\n should be replaced with their appropriate values. The colour and text of the image can be changed by altering \ndocs-stable-blue\n as described on \nshields.io\n, though it is recommended that package authors follow this standard to make it easier for potential users to find documentation links across multiple package README files.\n\n\n\n\nFinal Remarks\n\n\nThat should be all that is needed to enable automatic documentation building. Pushing new commits to your \nmaster\n branch should trigger doc builds. \nNote that other branches do not trigger these builds and neither do pull requests by potential contributors.\n\n\nIf you would like to see a more complete example of how this process is setup then take a look at this package's repository for some inspiration.", 
            "title": "Hosting Documentation"
        }, 
        {
            "location": "/man/hosting/#hosting-documentation", 
            "text": "After going through the  Package Guide  and  Doctests  page you will need to host the generated documentation somewhere for potential users to read. This guide will describe how to setup automatic updates for your package docs using the Travis build service and GitHub Pages. This is the same approach used by this package to host it's own docs \u2013 the docs you're currently reading.   Note  Following this guide should be the  final  step you take after you are comfortable with the syntax and build process used by  Documenter.jl . Only proceed with the steps outlined on this page once you have successfully used  mkdocs  locally to build your documentation.   mkdocs  can typically be installed using  pip install mkdocs  in your terminal.  This guide assumes that you already have GitHub and Travis accounts setup. If not then go set those up first and then return here.", 
            "title": "Hosting Documentation"
        }, 
        {
            "location": "/man/hosting/#overview", 
            "text": "Once setup correctly the following will happen each time you push new updates to your package repository:   travis buildbots startup and run your tests;  each buildbot will build the package docs using your  docs/make.jl  script;  a single buildbot will then try to push the generated docs back to github.   Note that the hosted documentation does not update when you make pull requests; you see updates only when you merge to  master  or push new tags.  The following sections outline how to enable this for your own package.", 
            "title": "Overview"
        }, 
        {
            "location": "/man/hosting/#deploy-keys", 
            "text": "Two methods are available for securely deploying generated documentation from Travis to GitHub. The first method listed below is the preferred approach. The second, and original, method should be avoided whenever possible.", 
            "title": "Deploy Keys"
        }, 
        {
            "location": "/man/hosting/#ssh-deploy-keys", 
            "text": "Deploy keys provide push access to a  single  repository.   Note  You will need several command line programs installed for the following steps to work. They are  which ,  git ,  ssh-keygen , and  travis .  Make sure these are installed before you begin.   Open a Julia REPL and import  Documenter .  julia   using   Documenter   Then call the  Travis.genkeys  function as follows:  julia   Travis . genkeys ( MyPackage )   where  \"MyPackage\"  is the name of the package you would like to create deploy keys for.  You may be asked to enter your password for Travis during this process. Once complete you will need to add the public key displayed in the REPL to your repository \u2013 just follow the instructions displayed in the REPL. If you see a line about adding an  openssl  command to your  .travis.yml  file, you can ignore that (Documenter will handle that for you).  Then close the REPL and commit the  docs/.documenter.enc  file that was generated by  Travis.genkeys  to the repository. You can skip the  GitHub Security Tokens  section and move straight on to  Travis Environment Settings  now.  If you don't get a  docs/.documenter.enc  file, one possible reason is an outdated version of  travis . At the time of this writing, version 1.8.2 was known to work.", 
            "title": "SSH Deploy Keys"
        }, 
        {
            "location": "/man/hosting/#github-security-tokens", 
            "text": "These tokens provide push access to  every  repository owned by the user.  Firstly, generate a new  personal access token .  Enter a description for this new token. We'll be calling ours \"Travis\", but any other name will do. For the \"Select scopes\" option choose \"public_repo\"  only . Then generate the token and save it somewhere safe. We'll be needing it during the next section.", 
            "title": "GitHub Security Tokens"
        }, 
        {
            "location": "/man/hosting/#travis-environment-settings", 
            "text": "", 
            "title": "Travis Environment Settings"
        }, 
        {
            "location": "/man/hosting/#ssh-keys", 
            "text": "If you used  Travis.genkeys  in the previous step then you should go to your Travis settings page and check that two new keys have been added with names similar to the following   encrypted_e6b49e69746a_key  encrypted_e6b49e69746a_iv", 
            "title": "SSH Keys"
        }, 
        {
            "location": "/man/hosting/#tokens", 
            "text": "If you generated a GitHub token during the previous step then we'll add the token to our repository's Travis page. Go to the settings page for the repository and under the \"Environment Variables\" section add a new variable called  GITHUB_API_KEY . Copy the generated key from the  GitHub Security Tokens  section as the value and  make sure  that \"Display value in build log\" is  off . Be careful to remove any leading white-space from the key. Then add the key.", 
            "title": "Tokens"
        }, 
        {
            "location": "/man/hosting/#travisyml-configuration", 
            "text": "In the  after_success  section of the  .travis.yml  file, where code coverage is processed, run your  docs/make.jl  file:  after_success : \n   -   julia -e  Pkg.add( Documenter ) \n   -   julia -e  cd(Pkg.dir( PACKAGE_NAME )); include(joinpath( docs ,  make.jl ))", 
            "title": ".travis.yml Configuration"
        }, 
        {
            "location": "/man/hosting/#the-deploydocs-function", 
            "text": "At the moment your  docs/make.jl  file probably only contains  using   Documenter ,   PACKAGE_NAME  makedocs ()   We'll need to add an additional call to this file after  makedocs . Add the following at the end of the file:  deploydocs ( \n     repo   =   github.com/USER_NAME/PACKAGE_NAME.jl.git  )   where  USER_NAME  and  PACKAGE_NAME  must be set to the appropriate names.  By default  deploydocs  will deploy the documentation from the  nightly  Julia build for Linux. This can be changed using the  julia  and  osname  keywords as follows:  deploydocs ( \n     deps     =   Deps . pip ( mkdocs ,   python-markdown-math ), \n     repo     =   github.com/USER_NAME/PACKAGE_NAME.jl.git , \n     julia    =   0.4 , \n     osname   =   osx  )   This will deploy the docs from the OSX Julia 0.4 Travis build bot.  The keyword  deps  serves to provide the required dependencies to deploy the documentation. In the example above we include the dependencies  mkdocs  and  python-markdown-math . The former makes sure that MkDocs is installed to deploy the documentation, and the latter provides the  mdx_math  markdown extension to exploit MathJax rendering of latex equations in markdown. Other dependencies should be included here.  See the  deploydocs  function documentation for more details.", 
            "title": "The deploydocs Function"
        }, 
        {
            "location": "/man/hosting/#the-mkdocs-mkdocsyml-file", 
            "text": "We'll be using  MkDocs  to convert the markdown files generated by Documenter to HTML. (This, of course, is not the only option you have for this step. Any markdown to HTML converter should work fine with some amount of setting up.)  Add an  mkdocs.yml  file to your  docs/  directory with the following content:  site_name :          PACKAGE_NAME.jl  repo_url :           https://github.com/USER_NAME/PACKAGE_NAME.jl  site_description :   Description...  site_author :        USER_NAME  theme :   readthedocs  extra_css : \n   -   assets/Documenter.css  extra_javascript : \n   -   https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML \n   -   assets/mathjaxhelper.js  markdown_extensions : \n   -   extra \n   -   tables \n   -   fenced_code \n   -   mdx_math  docs_dir :   build  pages : \n   -   Home :   index.md   This is only a basic skeleton. Read through the MkDocs documentation if you would like to know more about the available settings.", 
            "title": "The MkDocs mkdocs.yml File"
        }, 
        {
            "location": "/man/hosting/#gitignore", 
            "text": "Add the following to your package's  .gitignore  file  docs/build/\ndocs/site/  These are needed to avoid committing generated content to your repository.", 
            "title": ".gitignore"
        }, 
        {
            "location": "/man/hosting/#gh-pages-branch", 
            "text": "Create a new branch called  gh-pages  and push it to GitHub. If this branch already exists then you can skip this step, but do note that the generated content is automatically pushed to this branch from Travis.", 
            "title": "gh-pages Branch"
        }, 
        {
            "location": "/man/hosting/#documentation-versions", 
            "text": "When documentation is generated it is stored in one of the following folders:   latest  stores the most recent documentation that is committed to the  master  branch.  stable  stores the most recent documentation from a tagged commit. Older tagged versions are stored in directories named after their tags. These tagged directories are persistent and must be manually removed from the  gh-pages  branch if necessary.   Once your documentation has been pushed to the  gh-pages  branch you should add links to your  README.md  pointing to the  stable  and  latest  documentation URLs. It is common practice to make use of \"badges\" similar to those used for Travis and AppVeyor build statuses or code coverage. Adding the following to your package  README.md  should be all that is necessary:  [![](https://img.shields.io/badge/docs-stable-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/stable)\n[![](https://img.shields.io/badge/docs-latest-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/latest)  PACKAGE_NAME  and  USER_NAME  should be replaced with their appropriate values. The colour and text of the image can be changed by altering  docs-stable-blue  as described on  shields.io , though it is recommended that package authors follow this standard to make it easier for potential users to find documentation links across multiple package README files.   Final Remarks  That should be all that is needed to enable automatic documentation building. Pushing new commits to your  master  branch should trigger doc builds.  Note that other branches do not trigger these builds and neither do pull requests by potential contributors.  If you would like to see a more complete example of how this process is setup then take a look at this package's repository for some inspiration.", 
            "title": "Documentation Versions"
        }, 
        {
            "location": "/man/latex/", 
            "text": "$\\LaTeX$ syntax\n\n\nThe following section describes how to add equations written using $\\LaTeX$ to your documentation. There are some differences between Julia \n0.4\n and \n0.5\n that need to be taken into account when reading this section of the manual. These differences are outlined in the next two sections.\n\n\n\n\nJulia \n0.4\n\n\n\n\nInline equations\n\n\nSurround inline equations and mathematical symbols in \n$\n characters, i.e.\n\n\nHere\ns some inline maths: $\\sqrt[n]{1 + x + x^2 + \\ldots}$.\n\n\n\n\n\nwhich will be displayed as\n\n\n\n\nHere's some inline maths: $\\sqrt[n]{1 + x + x^2 + \\ldots}$.\n\n\n\n\n\n\nDisplay equations\n\n\nUse the same single \n$\n characters to wrap the equation, but also add a newline above and below it, i.e.\n\n\nHere\ns an equation:\n\n$\\frac{n!}{k!(n - k)!} = \\binom{n}{k}$\n\nThis is the binomial coefficient.\n\n\n\n\n\nwhich will be displayed as\n\n\n\n\nHere's an equation:\n\n\n\n\n\n\\frac{n!}{k!(n - k)!} = \\binom{n}{k}\n\n\n\n\n\nThis is the binomial coefficient.\n\n\n\n\n\n\nEscaping characters in docstrings\n\n\nSince some characters used in $\\LaTeX$ syntax are treated differently in docstrings they need to be escaped using a \n\\\n character as in the following example:\n\n\n\n\nHere\ns some inline maths: \\$\n\\\\\nsqrt[n]{1 + x + x^2 + \n\\\\\nldots}\\$.\n\n\n\nHere\ns an equation:\n\n\n\n\\$\n\\\\\nfrac{n!}{k!(n - k)!} = \n\\\\\nbinom{n}{k}\\$\n\n\n\nThis is the binomial coefficient.\n\n\n\n\nfunc\n(\nx\n)\n \n=\n \n# ...\n\n\n\n\n\n\nTo avoid needing to escape the special characters the \ndoc\"\"\n string macro can be used:\n\n\ndoc\n\n\nHere\ns some inline maths: $\\sqrt[n]{1 + x + x^2 + \\ldots}$.\n\n\n\nHere\ns an equation:\n\n\n\n$\n\\f\nrac{n!}{k!(n - k)!} = \n\\b\ninom{n}{k}$\n\n\n\nThis is the binomial coefficient.\n\n\n\n\nfunc\n(\nx\n)\n \n=\n \n# ...\n\n\n\n\n\n\n\n\nJulia \n0.5\n\n\nThe syntax from above, using \n$\ns, will still work in \n0.5\n, but it is recommended, if possible, to use the following double backtick syntax instead since it avoids overloading the meaning of the \n$\n character within docstrings.\n\n\n\n\nInline equations\n\n\nHere\ns some inline maths: ``\\sqrt[n]{1 + x + x^2 + \\ldots}``.\n\n\n\n\n\nwhich will be displayed as\n\n\n\n\nHere's some inline maths: $\\sqrt[n]{1 + x + x^2 + \\ldots}$.\n\n\n\n\n\n\nDisplay equations\n\n\nHere\ns an equation:\n\n```math\n\\frac{n!}{k!(n - k)!} = \\binom{n}{k}\n```\n\nThis is the binomial coefficient.\n\n\n\n\n\nwhich will be displayed as\n\n\n\n\nHere's an equation:\n\n\n\n\n\n\\frac{n!}{k!(n - k)!} = \\binom{n}{k}\n\n\n\n\n\nThis is the binomial coefficient.\n\n\n\n\n\n\nEscaping characters in docstrings\n\n\nIn the same way as in Julia \n0.4\n \n\\\n characters in docstrings must be escaped using a \n\\\n.\n\n\n\n\nMkDocs and MathJax\n\n\nTo get MkDocs to display $\\LaTeX$ equations correctly we need to update several of this configuration files described in the \nPackage Guide\n.\n\n\ndocs/make.jl\n should add the \npython-markdown-math\n dependency to allow for equations to be rendered correctly.\n\n\n# ...\n\n\n\ndeploydocs\n(\n\n    \ndeps\n \n=\n \nDeps\n.\npip\n(\npygments\n,\n \nmkdocs\n,\n \npython-markdown-math\n),\n\n    \n# ...\n\n\n)\n\n\n\n\n\n\nThis package should also be installed locally so that you can preview the generated documentation prior to pushing new commits to a repository.\n\n\n$ pip install python-markdown-math\n\n\n\n\n\nThe \ndocs/mkdocs.yml\n file must add the \npython-markdown-math\n extension, called \nmdx_math\n, as well as two MathJax JavaScript files:\n\n\n# ...\n\n\nmarkdown_extensions\n:\n\n  \n-\n \nmdx_math\n\n  \n# ...\n\n\n\nextra_javascript\n:\n\n  \n-\n \nhttps://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML\n\n  \n-\n \nassets/mathjaxhelper.js\n\n\n# ...\n\n\n\n\n\n\nFinal Remarks\n\n\nFollowing this guide and adding the necessary changes to the configuration files should enable properly rendered mathematical equations within your documentation both locally and when built and deployed using the Travis built service.", 
            "title": "LaTeX Syntax"
        }, 
        {
            "location": "/man/latex/#latex-syntax", 
            "text": "The following section describes how to add equations written using $\\LaTeX$ to your documentation. There are some differences between Julia  0.4  and  0.5  that need to be taken into account when reading this section of the manual. These differences are outlined in the next two sections.", 
            "title": "$\\LaTeX$ syntax"
        }, 
        {
            "location": "/man/latex/#julia-04", 
            "text": "", 
            "title": "Julia 0.4"
        }, 
        {
            "location": "/man/latex/#inline-equations", 
            "text": "Surround inline equations and mathematical symbols in  $  characters, i.e.  Here s some inline maths: $\\sqrt[n]{1 + x + x^2 + \\ldots}$.  which will be displayed as   Here's some inline maths: $\\sqrt[n]{1 + x + x^2 + \\ldots}$.", 
            "title": "Inline equations"
        }, 
        {
            "location": "/man/latex/#display-equations", 
            "text": "Use the same single  $  characters to wrap the equation, but also add a newline above and below it, i.e.  Here s an equation:\n\n$\\frac{n!}{k!(n - k)!} = \\binom{n}{k}$\n\nThis is the binomial coefficient.  which will be displayed as   Here's an equation:   \n\\frac{n!}{k!(n - k)!} = \\binom{n}{k}   This is the binomial coefficient.", 
            "title": "Display equations"
        }, 
        {
            "location": "/man/latex/#escaping-characters-in-docstrings", 
            "text": "Since some characters used in $\\LaTeX$ syntax are treated differently in docstrings they need to be escaped using a  \\  character as in the following example:   Here s some inline maths: \\$ \\\\ sqrt[n]{1 + x + x^2 +  \\\\ ldots}\\$.  Here s an equation:  \\$ \\\\ frac{n!}{k!(n - k)!} =  \\\\ binom{n}{k}\\$  This is the binomial coefficient.   func ( x )   =   # ...   To avoid needing to escape the special characters the  doc\"\"  string macro can be used:  doc  Here s some inline maths: $\\sqrt[n]{1 + x + x^2 + \\ldots}$.  Here s an equation:  $ \\f rac{n!}{k!(n - k)!} =  \\b inom{n}{k}$  This is the binomial coefficient.   func ( x )   =   # ...", 
            "title": "Escaping characters in docstrings"
        }, 
        {
            "location": "/man/latex/#julia-05", 
            "text": "The syntax from above, using  $ s, will still work in  0.5 , but it is recommended, if possible, to use the following double backtick syntax instead since it avoids overloading the meaning of the  $  character within docstrings.", 
            "title": "Julia 0.5"
        }, 
        {
            "location": "/man/latex/#inline-equations_1", 
            "text": "Here s some inline maths: ``\\sqrt[n]{1 + x + x^2 + \\ldots}``.  which will be displayed as   Here's some inline maths: $\\sqrt[n]{1 + x + x^2 + \\ldots}$.", 
            "title": "Inline equations"
        }, 
        {
            "location": "/man/latex/#display-equations_1", 
            "text": "Here s an equation:\n\n```math\n\\frac{n!}{k!(n - k)!} = \\binom{n}{k}\n```\n\nThis is the binomial coefficient.  which will be displayed as   Here's an equation:   \n\\frac{n!}{k!(n - k)!} = \\binom{n}{k}   This is the binomial coefficient.", 
            "title": "Display equations"
        }, 
        {
            "location": "/man/latex/#escaping-characters-in-docstrings_1", 
            "text": "In the same way as in Julia  0.4   \\  characters in docstrings must be escaped using a  \\ .", 
            "title": "Escaping characters in docstrings"
        }, 
        {
            "location": "/man/latex/#mkdocs-and-mathjax", 
            "text": "To get MkDocs to display $\\LaTeX$ equations correctly we need to update several of this configuration files described in the  Package Guide .  docs/make.jl  should add the  python-markdown-math  dependency to allow for equations to be rendered correctly.  # ...  deploydocs ( \n     deps   =   Deps . pip ( pygments ,   mkdocs ,   python-markdown-math ), \n     # ...  )   This package should also be installed locally so that you can preview the generated documentation prior to pushing new commits to a repository.  $ pip install python-markdown-math  The  docs/mkdocs.yml  file must add the  python-markdown-math  extension, called  mdx_math , as well as two MathJax JavaScript files:  # ...  markdown_extensions : \n   -   mdx_math \n   # ...  extra_javascript : \n   -   https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML \n   -   assets/mathjaxhelper.js  # ...   Final Remarks  Following this guide and adding the necessary changes to the configuration files should enable properly rendered mathematical equations within your documentation both locally and when built and deployed using the Travis built service.", 
            "title": "MkDocs and MathJax"
        }, 
        {
            "location": "/man/internals/", 
            "text": "Package Internals", 
            "title": "Internals"
        }, 
        {
            "location": "/man/internals/#package-internals", 
            "text": "", 
            "title": "Package Internals"
        }, 
        {
            "location": "/man/contributing/", 
            "text": "Contributing\n\n\nThis page details the some of the guidelines that should be followed when contributing to this package.\n\n\n\n\nBranches\n\n\nFrom \nDocumenter\n version \n0.3\n onwards \nrelease-*\n branches are used for tagged minor versions of this package. This follows the same approach used in the main Julia repository, albeit on a much more modest scale.\n\n\nPlease open pull requests against the \nmaster\n branch rather than any of the \nrelease-*\n branches whenever possible.\n\n\n\n\nBackports\n\n\nBug fixes are backported to the \nrelease-*\n branches using \ngit cherry-pick -x\n by a JuliaDocs member and will become available in point releases of that particular minor version of the package.\n\n\nFeel free to nominate commits that should be backported by opening an issue. Requests for new point releases to be tagged in \nMETADATA.jl\n can also be made in the same way.\n\n\n\n\nStyle Guide\n\n\nFollow the style of the surrounding text when making changes. When adding new features please try to stick to the following points whenever applicable.\n\n\n\n\nJulia\n\n\n\n\n4-space indentation;\n\n\nno blank lines at the start or end of files;\n\n\ndo not manually align syntax such as \n=\n or \n::\n over adjacent lines;\n\n\nuse \nlocal\n to define new local variables so that they are easier to locate;\n\n\nuse \nfunction ... end\n when a method definition contains more than one toplevel expression;\n\n\nrelated short-form method definitions don't need a new line between them;\n\n\nunrelated or long-form method definitions must have a blank line separating each one;\n\n\nsurround all binary operators with whitespace except for \n::\n, \n^\n, and \n:\n;\n\n\nfiles containing a single \nmodule ... end\n must be named after the module;\n\n\nmethod arguments should be ordered based on the amount of usage within the method body;\n\n\nmethods extended from other modules must follow their inherited argument order, not the above rule;\n\n\nexplicit \nreturn\n should be preferred except in short-form method definitions;\n\n\navoid dense expressions where possible e.g. prefer nested \nif\ns over complex nested \n?\ns;\n\n\ninclude a trailing \n,\n in vectors, tuples, or method calls that span several lines;\n\n\ndo not use multiline comments (\n#=\n and \n=#\n);\n\n\nwrap long lines as near to 92 characters as possible, this includes docstrings;\n\n\nfollow the standard naming conventions used in \nBase\n.\n\n\n\n\n\n\nMarkdown\n\n\n\n\nUse unbalanced \n#\n headers, i.e. no \n#\n on the right hand side of the header text;\n\n\ninclude a single blank line between toplevel blocks;\n\n\nunordered lists must use \n*\n bullets with two preceding spaces;\n\n\ndo \nnot\n hard wrap lines;\n\n\nuse emphasis (\n*\n) and bold (\n**\n) sparingly;\n\n\nalways use fenced code blocks instead of indented blocks;\n\n\nfollow the conventions outlined in the Julia documentation page on documentation.", 
            "title": "Contributing"
        }, 
        {
            "location": "/man/contributing/#contributing", 
            "text": "This page details the some of the guidelines that should be followed when contributing to this package.", 
            "title": "Contributing"
        }, 
        {
            "location": "/man/contributing/#branches", 
            "text": "From  Documenter  version  0.3  onwards  release-*  branches are used for tagged minor versions of this package. This follows the same approach used in the main Julia repository, albeit on a much more modest scale.  Please open pull requests against the  master  branch rather than any of the  release-*  branches whenever possible.", 
            "title": "Branches"
        }, 
        {
            "location": "/man/contributing/#backports", 
            "text": "Bug fixes are backported to the  release-*  branches using  git cherry-pick -x  by a JuliaDocs member and will become available in point releases of that particular minor version of the package.  Feel free to nominate commits that should be backported by opening an issue. Requests for new point releases to be tagged in  METADATA.jl  can also be made in the same way.", 
            "title": "Backports"
        }, 
        {
            "location": "/man/contributing/#style-guide", 
            "text": "Follow the style of the surrounding text when making changes. When adding new features please try to stick to the following points whenever applicable.", 
            "title": "Style Guide"
        }, 
        {
            "location": "/man/contributing/#julia", 
            "text": "4-space indentation;  no blank lines at the start or end of files;  do not manually align syntax such as  =  or  ::  over adjacent lines;  use  local  to define new local variables so that they are easier to locate;  use  function ... end  when a method definition contains more than one toplevel expression;  related short-form method definitions don't need a new line between them;  unrelated or long-form method definitions must have a blank line separating each one;  surround all binary operators with whitespace except for  :: ,  ^ , and  : ;  files containing a single  module ... end  must be named after the module;  method arguments should be ordered based on the amount of usage within the method body;  methods extended from other modules must follow their inherited argument order, not the above rule;  explicit  return  should be preferred except in short-form method definitions;  avoid dense expressions where possible e.g. prefer nested  if s over complex nested  ? s;  include a trailing  ,  in vectors, tuples, or method calls that span several lines;  do not use multiline comments ( #=  and  =# );  wrap long lines as near to 92 characters as possible, this includes docstrings;  follow the standard naming conventions used in  Base .", 
            "title": "Julia"
        }, 
        {
            "location": "/man/contributing/#markdown", 
            "text": "Use unbalanced  #  headers, i.e. no  #  on the right hand side of the header text;  include a single blank line between toplevel blocks;  unordered lists must use  *  bullets with two preceding spaces;  do  not  hard wrap lines;  use emphasis ( * ) and bold ( ** ) sparingly;  always use fenced code blocks instead of indented blocks;  follow the conventions outlined in the Julia documentation page on documentation.", 
            "title": "Markdown"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\nDocumentation for \nDocumenter.jl\n's public interface.\n\n\nSee \nInternal Documentation\n for internal package docs covering all submodules.\n\n\n\n\nContents\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nPublic Interface\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDocumenter\n\n\nDocumenter.Deps\n\n\nDocumenter.Travis\n\n\nDocumenter.Deps.pip\n\n\nDocumenter.Travis.genkeys\n\n\nDocumenter.deploydocs\n\n\nDocumenter.generate\n\n\nDocumenter.makedocs\n\n\n\n\n\n\nPublic Interface\n\n\n#\n\n\nDocumenter\n \n \nModule\n.\n\n\nMain module for \nDocumenter.jl\n \u2013 a documentation generation package for Julia.\n\n\nTwo functions are exported from this module for public use:\n\n\n\n\nmakedocs\n. Generates documentation from docstrings and templated markdown files.\n\n\ndeploydocs\n. Deploys generated documentation from \nTravis-CI\n to \nGitHub Pages\n.\n\n\n\n\nAdditionally it provides the unexported \nDocumenter.generate\n, which can be used to generate documentation stubs for new packages.\n\n\nExports\n\n\n\n\nDeps\n\n\nTravis\n\n\ndeploydocs\n\n\nmakedocs\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.makedocs\n \n \nFunction\n.\n\n\nmakedocs(\n    root    = \ncurrent-directory\n,\n    source  = \nsrc\n,\n    build   = \nbuild\n,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n    repo    = \n,\n)\n\n\n\n\n\nCombines markdown files and inline docstrings into an interlinked document. In most cases \nmakedocs\n should be run from a \nmake.jl\n file:\n\n\nusing\n \nDocumenter\n\n\nmakedocs\n(\n\n    \n# keywords...\n\n\n)\n\n\n\n\n\n\nwhich is then run from the command line with:\n\n\n$ julia make.jl\n\n\n\n\n\nThe folder structure that \nmakedocs\n expects looks like:\n\n\ndocs/\n    build/\n    src/\n    make.jl\n\n\n\n\n\nKeywords\n\n\nroot\n is the directory from which \nmakedocs\n should run. When run from a \nmake.jl\n file this keyword does not need to be set. It is, for the most part, needed when repeatedly running \nmakedocs\n from the Julia REPL like so:\n\n\njulia\n makedocs(root = Pkg.dir(\nMyPackage\n, \ndocs\n))\n\n\n\n\n\nsource\n is the directory, relative to \nroot\n, where the markdown source files are read from. By convention this folder is called \nsrc\n. Note that any non-markdown files stored in \nsource\n are copied over to the build directory when \nmakedocs\n is run.\n\n\nbuild\n is the directory, relative to \nroot\n, into which generated files and folders are written when \nmakedocs\n is run. The name of the build directory is, by convention, called \nbuild\n, though, like with \nsource\n, users are free to change this to anything else to better suit their project needs.\n\n\nclean\n tells \nmakedocs\n whether to remove all the content from the \nbuild\n folder prior to generating new content from \nsource\n. By default this is set to \ntrue\n.\n\n\ndoctest\n instructs \nmakedocs\n on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to \ntrue\n. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the \nDoctests\n manual section for details about running doctests.\n\n\nmodules\n specifies a vector of modules that should be documented in \nsource\n. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of \nmakedocs\n. By default no modules are passed to \nmodules\n and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation. For example Documenter's \nmake.jl\n file contains:\n\n\nmakedocs\n(\n\n    \nmodules\n \n=\n \n[\nDocumenter\n],\n\n    \n# ...\n\n\n)\n\n\n\n\n\n\nand so any docstring from the module \nDocumenter\n that is not spliced into the generated documentation in \nbuild\n will raise a warning.\n\n\nrepo\n specifies a template for the \"link to source\" feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:\n\n\n\n\n{commit}\n Git commit id\n\n\n{path}\n Path to the file in the repository\n\n\n{line}\n Line (or range of lines) in the source file\n\n\n\n\nFor example if you are using GitLab.com, you could use\n\n\nmakedocs\n(\nrepo\n \n=\n \nhttps://gitlab.com/user/project/blob/{commit}{path}#L{line}\n)\n\n\n\n\n\n\nSee Also\n\n\nA guide detailing how to document a package using Documenter's \nmakedocs\n is provided in the \nUsage\n section of the manual.\n\n\nsource\n\n\n#\n\n\nDocumenter.deploydocs\n \n \nFunction\n.\n\n\ndeploydocs(\n    root   = \ncurrent-directory\n,\n    target = \nsite\n,\n    repo   = \nrequired\n,\n    branch = \ngh-pages\n,\n    latest = \nmaster\n,\n    osname = \nlinux\n,\n    julia  = \nnightly\n,\n    deps   = \nFunction\n,\n    make   = \nFunction\n,\n)\n\n\n\n\n\nConverts markdown files generated by \nmakedocs\n to HTML and pushes them to \nrepo\n. This function should be called from within a package's \ndocs/make.jl\n file after the call to \nmakedocs\n, like so\n\n\nusing\n \nDocumenter\n,\n \nPACKAGE_NAME\n\n\nmakedocs\n(\n\n    \n# options...\n\n\n)\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/...\n\n\n)\n\n\n\n\n\n\nKeywords\n\n\nroot\n has the same purpose as the \nroot\n keyword for \nmakedocs\n.\n\n\ntarget\n is the directory, relative to \nroot\n, where generated HTML content should be written to. This directory \nmust\n be added to the repository's \n.gitignore\n file. The default value is \n\"site\"\n.\n\n\nrepo\n is the remote repository where generated HTML content should be pushed to. This keyword \nmust\n be set and will throw an error when left undefined. For example this package uses the following \nrepo\n value:\n\n\nrepo\n \n=\n \ngithub.com/JuliaDocs/Documenter.jl.git\n\n\n\n\n\n\nbranch\n is the branch where the generated documentation is pushed. By default this value is set to \n\"gh-pages\"\n.\n\n\nlatest\n is the branch that \"tracks\" the latest generated documentation. By default this value is set to \n\"master\"\n.\n\n\nosname\n is the operating system which will be used to deploy generated documentation. This defaults to \n\"linux\"\n. This value must be one of those specified in the \nos:\n section of the \n.travis.yml\n configuration file.\n\n\njulia\n is the version of Julia that will be used to deploy generated documentation. This defaults to \n\"nightly\"\n. This value must be one of those specified in the \njulia:\n section of the \n.travis.yml\n configuration file.\n\n\ndeps\n is the function used to install any dependancies needed to build the documentation. By default this function installs \npygments\n and \nmkdocs\n using the \nDeps.pip\n function:\n\n\ndeps\n \n=\n \nDeps\n.\npip\n(\npygments\n,\n \nmkdocs\n)\n\n\n\n\n\n\nmake\n is the function used to convert the markdown files to HTML. By default this just runs \nmkdocs build\n which populates the \ntarget\n directory.\n\n\nSee Also\n\n\nThe \nHosting Documentation\n section of the manual provides a step-by-step guide to using the \ndeploydocs\n function to automatically generate docs and push then to GitHub.\n\n\nsource\n\n\n#\n\n\nDocumenter.generate\n \n \nFunction\n.\n\n\nSignatures\n\n\ngenerate\n(\npkgname\n;\n \ndir\n)\n\n\n\n\n\n\nCreates a documentation stub for a package called \npkgname\n. The location of the documentation is assumed to be \npackage directory\n/docs\n, but this can be overriden with the keyword argument \ndir\n.\n\n\nIt creates the following files\n\n\ndocs/\n    .gitignore\n    src/index.md\n    make.jl\n    mkdocs.yml\n\n\n\n\n\nArguments\n\n\npkgname\n is the name of the package (without \n.jl\n). It is used to determine the location of the documentation if \ndir\n is not provided.\n\n\nKeywords\n\n\ndir\n defines the directory where the documentation will be generated. It defaults to \npackage directory\n/docs\n. The directory must not exist.\n\n\nExamples\n\n\njulia\n \nusing\n \nDocumenter\n\n\n\njulia\n \nDocumenter\n.\ngenerate\n(\nMyPackageName\n)\n\n\n[ ... output ... ]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Travis\n \n \nModule\n.\n\n\nPackage functions for interacting with Travis.\n\n\nExports\n\n\n\n\ngenkeys\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Travis.genkeys\n \n \nFunction\n.\n\n\nSignatures\n\n\ngenkeys\n(\npackage\n)\n\n\n\n\n\n\nGenerate ssh keys for package \npackage\n to automatically deploy docs from Travis to GitHub pages. Requires the following command lines programs to be installed:\n\n\n\n\nwhich\n\n\ngit\n\n\ntravis\n\n\nssh-keygen\n\n\n\n\nExamples\n\n\njulia\n \nusing\n \nDocumenter\n\n\n\njulia\n \nTravis\n.\ngenkeys\n(\nMyPackageName\n)\n\n\n[ ... output ... ]\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Deps\n \n \nModule\n.\n\n\nExported module that provides build and deploy dependancies and related functions.\n\n\nCurrently only \npip\n is implemented.\n\n\nsource\n\n\n#\n\n\nDocumenter.Deps.pip\n \n \nFunction\n.\n\n\nSignatures\n\n\npip\n(\ndeps\n)\n\n\n\n\n\n\nInstalls (as non-root user) all python packages listed in \ndeps\n.\n\n\nExamples\n\n\nusing\n \nDocumenter\n\n\n\nmakedocs\n(\n\n    \n# ...\n\n\n)\n\n\n\ndeploydocs\n(\n\n    \ndeps\n \n=\n \nDeps\n.\npip\n(\npygments\n,\n \nmkdocs\n,\n \nmkdocs-material\n),\n\n    \n# ...\n\n\n)\n\n\n\n\n\n\nsource", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "Documentation for  Documenter.jl 's public interface.  See  Internal Documentation  for internal package docs covering all submodules.", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/public/#contents", 
            "text": "Public Documentation  Contents  Index  Public Interface", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/public/#index", 
            "text": "Documenter  Documenter.Deps  Documenter.Travis  Documenter.Deps.pip  Documenter.Travis.genkeys  Documenter.deploydocs  Documenter.generate  Documenter.makedocs", 
            "title": "Index"
        }, 
        {
            "location": "/lib/public/#public-interface", 
            "text": "#  Documenter     Module .  Main module for  Documenter.jl  \u2013 a documentation generation package for Julia.  Two functions are exported from this module for public use:   makedocs . Generates documentation from docstrings and templated markdown files.  deploydocs . Deploys generated documentation from  Travis-CI  to  GitHub Pages .   Additionally it provides the unexported  Documenter.generate , which can be used to generate documentation stubs for new packages.  Exports   Deps  Travis  deploydocs  makedocs   source  #  Documenter.makedocs     Function .  makedocs(\n    root    =  current-directory ,\n    source  =  src ,\n    build   =  build ,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n    repo    =  ,\n)  Combines markdown files and inline docstrings into an interlinked document. In most cases  makedocs  should be run from a  make.jl  file:  using   Documenter  makedocs ( \n     # keywords...  )   which is then run from the command line with:  $ julia make.jl  The folder structure that  makedocs  expects looks like:  docs/\n    build/\n    src/\n    make.jl  Keywords  root  is the directory from which  makedocs  should run. When run from a  make.jl  file this keyword does not need to be set. It is, for the most part, needed when repeatedly running  makedocs  from the Julia REPL like so:  julia  makedocs(root = Pkg.dir( MyPackage ,  docs ))  source  is the directory, relative to  root , where the markdown source files are read from. By convention this folder is called  src . Note that any non-markdown files stored in  source  are copied over to the build directory when  makedocs  is run.  build  is the directory, relative to  root , into which generated files and folders are written when  makedocs  is run. The name of the build directory is, by convention, called  build , though, like with  source , users are free to change this to anything else to better suit their project needs.  clean  tells  makedocs  whether to remove all the content from the  build  folder prior to generating new content from  source . By default this is set to  true .  doctest  instructs  makedocs  on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to  true . Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the  Doctests  manual section for details about running doctests.  modules  specifies a vector of modules that should be documented in  source . If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of  makedocs . By default no modules are passed to  modules  and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation. For example Documenter's  make.jl  file contains:  makedocs ( \n     modules   =   [ Documenter ], \n     # ...  )   and so any docstring from the module  Documenter  that is not spliced into the generated documentation in  build  will raise a warning.  repo  specifies a template for the \"link to source\" feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:   {commit}  Git commit id  {path}  Path to the file in the repository  {line}  Line (or range of lines) in the source file   For example if you are using GitLab.com, you could use  makedocs ( repo   =   https://gitlab.com/user/project/blob/{commit}{path}#L{line} )   See Also  A guide detailing how to document a package using Documenter's  makedocs  is provided in the  Usage  section of the manual.  source  #  Documenter.deploydocs     Function .  deploydocs(\n    root   =  current-directory ,\n    target =  site ,\n    repo   =  required ,\n    branch =  gh-pages ,\n    latest =  master ,\n    osname =  linux ,\n    julia  =  nightly ,\n    deps   =  Function ,\n    make   =  Function ,\n)  Converts markdown files generated by  makedocs  to HTML and pushes them to  repo . This function should be called from within a package's  docs/make.jl  file after the call to  makedocs , like so  using   Documenter ,   PACKAGE_NAME  makedocs ( \n     # options...  )  deploydocs ( \n     repo   =   github.com/...  )   Keywords  root  has the same purpose as the  root  keyword for  makedocs .  target  is the directory, relative to  root , where generated HTML content should be written to. This directory  must  be added to the repository's  .gitignore  file. The default value is  \"site\" .  repo  is the remote repository where generated HTML content should be pushed to. This keyword  must  be set and will throw an error when left undefined. For example this package uses the following  repo  value:  repo   =   github.com/JuliaDocs/Documenter.jl.git   branch  is the branch where the generated documentation is pushed. By default this value is set to  \"gh-pages\" .  latest  is the branch that \"tracks\" the latest generated documentation. By default this value is set to  \"master\" .  osname  is the operating system which will be used to deploy generated documentation. This defaults to  \"linux\" . This value must be one of those specified in the  os:  section of the  .travis.yml  configuration file.  julia  is the version of Julia that will be used to deploy generated documentation. This defaults to  \"nightly\" . This value must be one of those specified in the  julia:  section of the  .travis.yml  configuration file.  deps  is the function used to install any dependancies needed to build the documentation. By default this function installs  pygments  and  mkdocs  using the  Deps.pip  function:  deps   =   Deps . pip ( pygments ,   mkdocs )   make  is the function used to convert the markdown files to HTML. By default this just runs  mkdocs build  which populates the  target  directory.  See Also  The  Hosting Documentation  section of the manual provides a step-by-step guide to using the  deploydocs  function to automatically generate docs and push then to GitHub.  source  #  Documenter.generate     Function .  Signatures  generate ( pkgname ;   dir )   Creates a documentation stub for a package called  pkgname . The location of the documentation is assumed to be  package directory /docs , but this can be overriden with the keyword argument  dir .  It creates the following files  docs/\n    .gitignore\n    src/index.md\n    make.jl\n    mkdocs.yml  Arguments  pkgname  is the name of the package (without  .jl ). It is used to determine the location of the documentation if  dir  is not provided.  Keywords  dir  defines the directory where the documentation will be generated. It defaults to  package directory /docs . The directory must not exist.  Examples  julia   using   Documenter  julia   Documenter . generate ( MyPackageName )  [ ... output ... ]   source  #  Documenter.Travis     Module .  Package functions for interacting with Travis.  Exports   genkeys   source  #  Documenter.Travis.genkeys     Function .  Signatures  genkeys ( package )   Generate ssh keys for package  package  to automatically deploy docs from Travis to GitHub pages. Requires the following command lines programs to be installed:   which  git  travis  ssh-keygen   Examples  julia   using   Documenter  julia   Travis . genkeys ( MyPackageName )  [ ... output ... ]   source  #  Documenter.Deps     Module .  Exported module that provides build and deploy dependancies and related functions.  Currently only  pip  is implemented.  source  #  Documenter.Deps.pip     Function .  Signatures  pip ( deps )   Installs (as non-root user) all python packages listed in  deps .  Examples  using   Documenter  makedocs ( \n     # ...  )  deploydocs ( \n     deps   =   Deps . pip ( pygments ,   mkdocs ,   mkdocs-material ), \n     # ...  )   source", 
            "title": "Public Interface"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\nThis page lists all the documented internals of the \nDocumenter\n module and submodules.\n\n\n\n\nContents\n\n\n\n\nAnchors\n\n\nBuilder\n\n\nCrossReferences\n\n\nDocChecks\n\n\nDocSystem\n\n\nDocuments\n\n\nDOM\n\n\nExpanders\n\n\nFormats\n\n\nGenerator\n\n\nSelectors\n\n\nUtilities\n\n\nWalkers\n\n\nWriters\n\n\n\n\n\n\nIndex\n\n\nA list of all internal documentation sorted by module.\n\n\n\n\nDocumenter.Anchors\n\n\nDocumenter.Anchors.Anchor\n\n\nDocumenter.Anchors.AnchorMap\n\n\nDocumenter.Anchors.add!\n\n\nDocumenter.Anchors.anchor\n\n\nDocumenter.Anchors.exists\n\n\nDocumenter.Anchors.isunique\n\n\nDocumenter.Builder\n\n\nDocumenter.Builder.CheckDocument\n\n\nDocumenter.Builder.CrossReferences\n\n\nDocumenter.Builder.DocumentPipeline\n\n\nDocumenter.Builder.ExpandTemplates\n\n\nDocumenter.Builder.Populate\n\n\nDocumenter.Builder.RenderDocument\n\n\nDocumenter.Builder.SetupBuildDirectory\n\n\nDocumenter.Builder.walk_navpages\n\n\nDocumenter.CrossReferences\n\n\nDocumenter.CrossReferences.crossref\n\n\nDocumenter.CrossReferences.find_object\n\n\nDocumenter.DocChecks\n\n\nDocumenter.DocChecks.doctest\n\n\nDocumenter.DocChecks.missingdocs\n\n\nDocumenter.DocSystem\n\n\nDocumenter.DocSystem.binding\n\n\nDocumenter.DocSystem.convertmeta\n\n\nDocumenter.DocSystem.docstr\n\n\nDocumenter.DocSystem.getdocs\n\n\nDocumenter.DocSystem.getdocs\n\n\nDocumenter.DocSystem.multidoc\n\n\nDocumenter.Documents\n\n\nDocumenter.Documents.Document\n\n\nDocumenter.Documents.Globals\n\n\nDocumenter.Documents.Internal\n\n\nDocumenter.Documents.NavNode\n\n\nDocumenter.Documents.Page\n\n\nDocumenter.Documents.User\n\n\nDocumenter.Documents.navpath\n\n\nDocumenter.Documents.populate!\n\n\nDocumenter.Utilities.DOM\n\n\nDocumenter.Utilities.DOM.Node\n\n\nDocumenter.Utilities.DOM.Tag\n\n\nDocumenter.Utilities.DOM.escapehtml\n\n\nDocumenter.Utilities.DOM.flatten!\n\n\nDocumenter.Utilities.DOM.@tags\n\n\nDocumenter.Expanders\n\n\nDocumenter.Expanders.AutoDocsBlocks\n\n\nDocumenter.Expanders.ContentsBlocks\n\n\nDocumenter.Expanders.DocsBlocks\n\n\nDocumenter.Expanders.EvalBlocks\n\n\nDocumenter.Expanders.ExampleBlocks\n\n\nDocumenter.Expanders.ExpanderPipeline\n\n\nDocumenter.Expanders.IndexBlocks\n\n\nDocumenter.Expanders.MetaBlocks\n\n\nDocumenter.Expanders.REPLBlocks\n\n\nDocumenter.Expanders.TrackHeaders\n\n\nDocumenter.Formats\n\n\nDocumenter.Formats.Format\n\n\nDocumenter.Formats.mimetype\n\n\nDocumenter.Generator\n\n\nDocumenter.Generator.gitignore\n\n\nDocumenter.Generator.index\n\n\nDocumenter.Generator.make\n\n\nDocumenter.Generator.mkdocs\n\n\nDocumenter.Generator.savefile\n\n\nDocumenter.Selectors\n\n\nDocumenter.Selectors.AbstractSelector\n\n\nDocumenter.Selectors.disable\n\n\nDocumenter.Selectors.dispatch\n\n\nDocumenter.Selectors.matcher\n\n\nDocumenter.Selectors.order\n\n\nDocumenter.Selectors.runner\n\n\nDocumenter.Selectors.strict\n\n\nDocumenter.Utilities\n\n\nDocumenter.Utilities.Object\n\n\nDocumenter.Utilities.assetsdir\n\n\nDocumenter.Utilities.check_kwargs\n\n\nDocumenter.Utilities.currentdir\n\n\nDocumenter.Utilities.doccat\n\n\nDocumenter.Utilities.docs\n\n\nDocumenter.Utilities.filterdocs\n\n\nDocumenter.Utilities.issubmodule\n\n\nDocumenter.Utilities.log\n\n\nDocumenter.Utilities.logging\n\n\nDocumenter.Utilities.nodocs\n\n\nDocumenter.Utilities.object\n\n\nDocumenter.Utilities.parseblock\n\n\nDocumenter.Utilities.slugify\n\n\nDocumenter.Utilities.srcpath\n\n\nDocumenter.Utilities.submodules\n\n\nDocumenter.Utilities.warn\n\n\nDocumenter.Utilities.withoutput\n\n\nDocumenter.Walkers\n\n\nDocumenter.Walkers.walk\n\n\nDocumenter.Writers\n\n\nDocumenter.Writers.HTMLWriter\n\n\nDocumenter.Writers.LaTeXWriter\n\n\nDocumenter.Writers.MarkdownWriter\n\n\nDocumenter.Writers.Writer\n\n\nDocumenter.Writers.HTMLWriter.mdconvert\n\n\nDocumenter.Writers.render", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internal-documentation", 
            "text": "This page lists all the documented internals of the  Documenter  module and submodules.", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/lib/internals/#contents", 
            "text": "Anchors  Builder  CrossReferences  DocChecks  DocSystem  Documents  DOM  Expanders  Formats  Generator  Selectors  Utilities  Walkers  Writers", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/internals/#index", 
            "text": "A list of all internal documentation sorted by module.   Documenter.Anchors  Documenter.Anchors.Anchor  Documenter.Anchors.AnchorMap  Documenter.Anchors.add!  Documenter.Anchors.anchor  Documenter.Anchors.exists  Documenter.Anchors.isunique  Documenter.Builder  Documenter.Builder.CheckDocument  Documenter.Builder.CrossReferences  Documenter.Builder.DocumentPipeline  Documenter.Builder.ExpandTemplates  Documenter.Builder.Populate  Documenter.Builder.RenderDocument  Documenter.Builder.SetupBuildDirectory  Documenter.Builder.walk_navpages  Documenter.CrossReferences  Documenter.CrossReferences.crossref  Documenter.CrossReferences.find_object  Documenter.DocChecks  Documenter.DocChecks.doctest  Documenter.DocChecks.missingdocs  Documenter.DocSystem  Documenter.DocSystem.binding  Documenter.DocSystem.convertmeta  Documenter.DocSystem.docstr  Documenter.DocSystem.getdocs  Documenter.DocSystem.getdocs  Documenter.DocSystem.multidoc  Documenter.Documents  Documenter.Documents.Document  Documenter.Documents.Globals  Documenter.Documents.Internal  Documenter.Documents.NavNode  Documenter.Documents.Page  Documenter.Documents.User  Documenter.Documents.navpath  Documenter.Documents.populate!  Documenter.Utilities.DOM  Documenter.Utilities.DOM.Node  Documenter.Utilities.DOM.Tag  Documenter.Utilities.DOM.escapehtml  Documenter.Utilities.DOM.flatten!  Documenter.Utilities.DOM.@tags  Documenter.Expanders  Documenter.Expanders.AutoDocsBlocks  Documenter.Expanders.ContentsBlocks  Documenter.Expanders.DocsBlocks  Documenter.Expanders.EvalBlocks  Documenter.Expanders.ExampleBlocks  Documenter.Expanders.ExpanderPipeline  Documenter.Expanders.IndexBlocks  Documenter.Expanders.MetaBlocks  Documenter.Expanders.REPLBlocks  Documenter.Expanders.TrackHeaders  Documenter.Formats  Documenter.Formats.Format  Documenter.Formats.mimetype  Documenter.Generator  Documenter.Generator.gitignore  Documenter.Generator.index  Documenter.Generator.make  Documenter.Generator.mkdocs  Documenter.Generator.savefile  Documenter.Selectors  Documenter.Selectors.AbstractSelector  Documenter.Selectors.disable  Documenter.Selectors.dispatch  Documenter.Selectors.matcher  Documenter.Selectors.order  Documenter.Selectors.runner  Documenter.Selectors.strict  Documenter.Utilities  Documenter.Utilities.Object  Documenter.Utilities.assetsdir  Documenter.Utilities.check_kwargs  Documenter.Utilities.currentdir  Documenter.Utilities.doccat  Documenter.Utilities.docs  Documenter.Utilities.filterdocs  Documenter.Utilities.issubmodule  Documenter.Utilities.log  Documenter.Utilities.logging  Documenter.Utilities.nodocs  Documenter.Utilities.object  Documenter.Utilities.parseblock  Documenter.Utilities.slugify  Documenter.Utilities.srcpath  Documenter.Utilities.submodules  Documenter.Utilities.warn  Documenter.Utilities.withoutput  Documenter.Walkers  Documenter.Walkers.walk  Documenter.Writers  Documenter.Writers.HTMLWriter  Documenter.Writers.LaTeXWriter  Documenter.Writers.MarkdownWriter  Documenter.Writers.Writer  Documenter.Writers.HTMLWriter.mdconvert  Documenter.Writers.render", 
            "title": "Index"
        }, 
        {
            "location": "/lib/internals/anchors/", 
            "text": "Anchors\n\n\n#\n\n\nDocumenter.Anchors\n \n \nModule\n.\n\n\nDefines the \nAnchor\n and \nAnchorMap\n types.\n\n\nAnchor\ns and \nAnchorMap\ns are used to represent links between objects within a document.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.Anchor\n \n \nType\n.\n\n\nStores an arbitrary object called \n.object\n and it's location within a document.\n\n\nFields\n\n\n\n\nobject\n \u2013 the stored object.\n\n\norder\n  \u2013 ordering of \nobject\n within the entire document.\n\n\nfile\n   \u2013 the destination file, in \nbuild\n, where the object will be written to.\n\n\nid\n     \u2013 the generated \"slug\" identifying the object.\n\n\nnth\n    \u2013 integer that unique-ifies anchors with the same \nid\n.\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.AnchorMap\n \n \nType\n.\n\n\nTree structure representating anchors in a document and their relationships with eachother.\n\n\nObject Hierarchy\n\n\nid -\n file -\n anchors\n\n\n\n\n\nEach \nid\n maps to a \nfile\n which in turn maps to a vector of \nAnchor\n objects.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.add!\n \n \nMethod\n.\n\n\nSignatures\n\n\nadd!\n(\nm\n,\n \nanchor\n,\n \nid\n,\n \nfile\n)\n\n\n\n\n\n\nAdds a new \nAnchor\n to the \nAnchorMap\n for a given \nid\n and \nfile\n.\n\n\nEither an actual \nAnchor\n object may be provided or any other object which is automatically wrapped in an \nAnchor\n before being added to the \nAnchorMap\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.anchor\n \n \nMethod\n.\n\n\nSignatures\n\n\nanchor\n(\nm\n,\n \nid\n)\n\n\n\n\n\n\nReturns the \nAnchor\n object matching \nid\n. \nfile\n and \nn\n may also be provided. A \nNullable{Anchor}\n is returned which must be unwrapped with \nisnull\n and \nget\n before use.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.exists\n \n \nMethod\n.\n\n\nSignatures\n\n\nexists\n(\nm\n,\n \nid\n,\n \nfile\n,\n \nn\n)\n\n\n\n\n\n\nDoes the given \nid\n exist within the \nAnchorMap\n? A \nfile\n and integer \nn\n may also be provided to narrow the search for existance.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.isunique\n \n \nMethod\n.\n\n\nSignatures\n\n\nisunique\n(\nm\n,\n \nid\n)\n\n\n\n\n\n\nIs the \nid\n unique within the given \nAnchorMap\n? May also specify the \nfile\n.\n\n\nsource", 
            "title": "Anchors"
        }, 
        {
            "location": "/lib/internals/anchors/#anchors", 
            "text": "#  Documenter.Anchors     Module .  Defines the  Anchor  and  AnchorMap  types.  Anchor s and  AnchorMap s are used to represent links between objects within a document.  source  #  Documenter.Anchors.Anchor     Type .  Stores an arbitrary object called  .object  and it's location within a document.  Fields   object  \u2013 the stored object.  order   \u2013 ordering of  object  within the entire document.  file    \u2013 the destination file, in  build , where the object will be written to.  id      \u2013 the generated \"slug\" identifying the object.  nth     \u2013 integer that unique-ifies anchors with the same  id .   source  #  Documenter.Anchors.AnchorMap     Type .  Tree structure representating anchors in a document and their relationships with eachother.  Object Hierarchy  id -  file -  anchors  Each  id  maps to a  file  which in turn maps to a vector of  Anchor  objects.  source  #  Documenter.Anchors.add!     Method .  Signatures  add! ( m ,   anchor ,   id ,   file )   Adds a new  Anchor  to the  AnchorMap  for a given  id  and  file .  Either an actual  Anchor  object may be provided or any other object which is automatically wrapped in an  Anchor  before being added to the  AnchorMap .  source  #  Documenter.Anchors.anchor     Method .  Signatures  anchor ( m ,   id )   Returns the  Anchor  object matching  id .  file  and  n  may also be provided. A  Nullable{Anchor}  is returned which must be unwrapped with  isnull  and  get  before use.  source  #  Documenter.Anchors.exists     Method .  Signatures  exists ( m ,   id ,   file ,   n )   Does the given  id  exist within the  AnchorMap ? A  file  and integer  n  may also be provided to narrow the search for existance.  source  #  Documenter.Anchors.isunique     Method .  Signatures  isunique ( m ,   id )   Is the  id  unique within the given  AnchorMap ? May also specify the  file .  source", 
            "title": "Anchors"
        }, 
        {
            "location": "/lib/internals/builder/", 
            "text": "Builder\n\n\n#\n\n\nDocumenter.Builder\n \n \nModule\n.\n\n\nDefines the \nDocumenter.jl\n build \"pipeline\" named \nDocumentPipeline\n.\n\n\nEach stage of the pipeline performs an action on a \nDocuments.Document\n object. These actions may involve creating directory structures, expanding templates, running doctests, etc.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.CheckDocument\n \n \nType\n.\n\n\nChecks that all documented objects are included in the document and runs doctests on all valid Julia code blocks.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.CrossReferences\n \n \nType\n.\n\n\nFinds and sets URLs for each \n@ref\n link in the document to the correct destinations.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.DocumentPipeline\n \n \nType\n.\n\n\nThe default document processing \"pipeline\", which consists of the following actions:\n\n\n\n\nSetupBuildDirectory\n\n\nExpandTemplates\n\n\nCrossReferences\n\n\nCheckDocument\n\n\nPopulate\n\n\nRenderDocument\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.ExpandTemplates\n \n \nType\n.\n\n\nExecutes a sequence of actions on each node of the parsed markdown files in turn.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.Populate\n \n \nType\n.\n\n\nPopulates the \nContentsNode\ns and \nIndexNode\ns with links.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.RenderDocument\n \n \nType\n.\n\n\nWrites the document tree to the \nbuild\n directory.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.SetupBuildDirectory\n \n \nType\n.\n\n\nCreates the correct directory layout within the \nbuild\n folder and parses markdown files.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.walk_navpages\n \n \nMethod\n.\n\n\nSignatures\n\n\nwalk_navpages\n(\nps\n,\n \nparent\n,\n \ndoc\n)\n\n\n\n\n\n\nRecursively walks through the \nDocuments.Document\n's \n.user.pages\n field, generating \nDocuments.NavNode\ns and related data structures in the process.\n\n\nThis implementation is the de facto specification for the \n.user.pages\n field.\n\n\nsource", 
            "title": "Builder"
        }, 
        {
            "location": "/lib/internals/builder/#builder", 
            "text": "#  Documenter.Builder     Module .  Defines the  Documenter.jl  build \"pipeline\" named  DocumentPipeline .  Each stage of the pipeline performs an action on a  Documents.Document  object. These actions may involve creating directory structures, expanding templates, running doctests, etc.  source  #  Documenter.Builder.CheckDocument     Type .  Checks that all documented objects are included in the document and runs doctests on all valid Julia code blocks.  source  #  Documenter.Builder.CrossReferences     Type .  Finds and sets URLs for each  @ref  link in the document to the correct destinations.  source  #  Documenter.Builder.DocumentPipeline     Type .  The default document processing \"pipeline\", which consists of the following actions:   SetupBuildDirectory  ExpandTemplates  CrossReferences  CheckDocument  Populate  RenderDocument   source  #  Documenter.Builder.ExpandTemplates     Type .  Executes a sequence of actions on each node of the parsed markdown files in turn.  source  #  Documenter.Builder.Populate     Type .  Populates the  ContentsNode s and  IndexNode s with links.  source  #  Documenter.Builder.RenderDocument     Type .  Writes the document tree to the  build  directory.  source  #  Documenter.Builder.SetupBuildDirectory     Type .  Creates the correct directory layout within the  build  folder and parses markdown files.  source  #  Documenter.Builder.walk_navpages     Method .  Signatures  walk_navpages ( ps ,   parent ,   doc )   Recursively walks through the  Documents.Document 's  .user.pages  field, generating  Documents.NavNode s and related data structures in the process.  This implementation is the de facto specification for the  .user.pages  field.  source", 
            "title": "Builder"
        }, 
        {
            "location": "/lib/internals/cross-references/", 
            "text": "CrossReferences\n\n\n#\n\n\nDocumenter.CrossReferences\n \n \nModule\n.\n\n\nProvides the \ncrossref\n function used to automatically calculate link URLs.\n\n\nsource\n\n\n#\n\n\nDocumenter.CrossReferences.crossref\n \n \nMethod\n.\n\n\nSignatures\n\n\ncrossref\n(\ndoc\n)\n\n\n\n\n\n\nTraverses a \nDocuments.Document\n and replaces links containg \n@ref\n URLs with their real URLs.\n\n\nsource\n\n\n#\n\n\nDocumenter.CrossReferences.find_object\n \n \nMethod\n.\n\n\nSignatures\n\n\nfind_object\n(\ndoc\n,\n \nbinding\n,\n \ntypesig\n)\n\n\n\n\n\n\nFind the included \nObject\n in the \ndoc\n matching \nbinding\n and \ntypesig\n. The matching heuristic isn't too picky about what matches and will only fail when no \nBinding\ns matching \nbinding\n have been included.\n\n\nsource", 
            "title": "CrossReferences"
        }, 
        {
            "location": "/lib/internals/cross-references/#crossreferences", 
            "text": "#  Documenter.CrossReferences     Module .  Provides the  crossref  function used to automatically calculate link URLs.  source  #  Documenter.CrossReferences.crossref     Method .  Signatures  crossref ( doc )   Traverses a  Documents.Document  and replaces links containg  @ref  URLs with their real URLs.  source  #  Documenter.CrossReferences.find_object     Method .  Signatures  find_object ( doc ,   binding ,   typesig )   Find the included  Object  in the  doc  matching  binding  and  typesig . The matching heuristic isn't too picky about what matches and will only fail when no  Binding s matching  binding  have been included.  source", 
            "title": "CrossReferences"
        }, 
        {
            "location": "/lib/internals/docchecks/", 
            "text": "DocChecks\n\n\n#\n\n\nDocumenter.DocChecks\n \n \nModule\n.\n\n\nProvides two functions, \nmissingdocs\n and \ndoctest\n, for checking docs.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocChecks.doctest\n \n \nMethod\n.\n\n\nSignatures\n\n\ndoctest\n(\ndoc\n)\n\n\n\n\n\n\nTraverses the document tree and tries to run each Julia code block encountered. Will abort the document generation when an error is thrown. Use \ndoctest = false\n keyword in \nDocumenter.makedocs\n to disable doctesting.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocChecks.missingdocs\n \n \nMethod\n.\n\n\nSignatures\n\n\nmissingdocs\n(\ndoc\n)\n\n\n\n\n\n\nChecks that a \nDocuments.Document\n contains all available docstrings that are defined in the \nmodules\n keyword passed to \nDocumenter.makedocs\n.\n\n\nPrints out the name of each object that has not had its docs spliced into the document.\n\n\nsource", 
            "title": "DocChecks"
        }, 
        {
            "location": "/lib/internals/docchecks/#docchecks", 
            "text": "#  Documenter.DocChecks     Module .  Provides two functions,  missingdocs  and  doctest , for checking docs.  source  #  Documenter.DocChecks.doctest     Method .  Signatures  doctest ( doc )   Traverses the document tree and tries to run each Julia code block encountered. Will abort the document generation when an error is thrown. Use  doctest = false  keyword in  Documenter.makedocs  to disable doctesting.  source  #  Documenter.DocChecks.missingdocs     Method .  Signatures  missingdocs ( doc )   Checks that a  Documents.Document  contains all available docstrings that are defined in the  modules  keyword passed to  Documenter.makedocs .  Prints out the name of each object that has not had its docs spliced into the document.  source", 
            "title": "DocChecks"
        }, 
        {
            "location": "/lib/internals/docsystem/", 
            "text": "DocSystem\n\n\n#\n\n\nDocumenter.DocSystem\n \n \nModule\n.\n\n\nProvides a consistent interface to retreiving \nDocStr\n objects from the Julia docsystem in both \n0.4\n and \n0.5\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocSystem.binding\n \n \nMethod\n.\n\n\nConverts an object to a \nBase.Docs.Binding\n object.\n\n\nSignatures\n\n\nbinding\n(\nany\n)\n\n\n\n\n\n\nSupported inputs are:\n\n\n\n\nBinding\n\n\nDataType\n\n\nFunction\n\n\nModule\n\n\nSymbol\n\n\n\n\nNote that unsupported objects will throw an \nArgumentError\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocSystem.convertmeta\n \n \nMethod\n.\n\n\nSignatures\n\n\nconvertmeta\n(\nmeta\n)\n\n\n\n\n\n\nConverts a \n0.4\n-style docstring cache into a \n0.5\n one.\n\n\nThe original docstring cache is not modified.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocSystem.docstr\n \n \nMethod\n.\n\n\nSignatures\n\n\ndocstr\n(\nmd\n;\n \nkws\n...\n)\n\n\n\n\n\n\nConstruct a \nDocStr\n object from a \nMarkdown.MD\n object.\n\n\nThe optional keyword arguments are used to add new data to the \nDocStr\n's \n.data\n dictionary.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocSystem.getdocs\n \n \nFunction\n.\n\n\nSignatures\n\n\ngetdocs\n(\nbinding\n)\n\n\ngetdocs\n(\nbinding\n,\n \ntypesig\n;\n \naliases\n,\n \ncompare\n,\n \nmodules\n)\n\n\n\n\n\n\nFind all \nDocStr\n objects that match the provided arguments:\n\n\n\n\nbinding\n: the name of the object.\n\n\ntypesig\n: the signature of the object. Default: \nUnion{}\n.\n\n\ncompare\n: how to compare signatures? Exact (\n==\n) or subtypes (\n:\n). Default: \n:\n.\n\n\nmodules\n: which modules to search through. Default: \nall modules\n.\n\n\naliases\n: check aliases of \nbinding\n when nothing is found. Default: \ntrue\n.\n\n\n\n\nReturns a \nVector{DocStr}\n ordered by definition order in \n0.5\n and by \ntype_morespecific\n in \n0.4\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocSystem.getdocs\n \n \nFunction\n.\n\n\nSignatures\n\n\ngetdocs\n(\nobject\n)\n\n\ngetdocs\n(\nobject\n,\n \ntypesig\n;\n \nkws\n...\n)\n\n\n\n\n\n\nAccepts objects of any type and tries to convert them to \nBinding\ns before searching for the \nBinding\n in the docsystem.\n\n\nNote that when conversion fails this method returns an empty \nVector{DocStr}\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocSystem.multidoc\n \n \nFunction\n.\n\n\nConstruct a \nMultiDoc\n object from the provided argument.\n\n\nValid inputs are:\n\n\n\n\nMarkdown.MD\n\n\nDocs.FuncDoc\n\n\nDocs.TypeDoc\n\n\n\n\nsource", 
            "title": "DocSystem"
        }, 
        {
            "location": "/lib/internals/docsystem/#docsystem", 
            "text": "#  Documenter.DocSystem     Module .  Provides a consistent interface to retreiving  DocStr  objects from the Julia docsystem in both  0.4  and  0.5 .  source  #  Documenter.DocSystem.binding     Method .  Converts an object to a  Base.Docs.Binding  object.  Signatures  binding ( any )   Supported inputs are:   Binding  DataType  Function  Module  Symbol   Note that unsupported objects will throw an  ArgumentError .  source  #  Documenter.DocSystem.convertmeta     Method .  Signatures  convertmeta ( meta )   Converts a  0.4 -style docstring cache into a  0.5  one.  The original docstring cache is not modified.  source  #  Documenter.DocSystem.docstr     Method .  Signatures  docstr ( md ;   kws ... )   Construct a  DocStr  object from a  Markdown.MD  object.  The optional keyword arguments are used to add new data to the  DocStr 's  .data  dictionary.  source  #  Documenter.DocSystem.getdocs     Function .  Signatures  getdocs ( binding )  getdocs ( binding ,   typesig ;   aliases ,   compare ,   modules )   Find all  DocStr  objects that match the provided arguments:   binding : the name of the object.  typesig : the signature of the object. Default:  Union{} .  compare : how to compare signatures? Exact ( == ) or subtypes ( : ). Default:  : .  modules : which modules to search through. Default:  all modules .  aliases : check aliases of  binding  when nothing is found. Default:  true .   Returns a  Vector{DocStr}  ordered by definition order in  0.5  and by  type_morespecific  in  0.4 .  source  #  Documenter.DocSystem.getdocs     Function .  Signatures  getdocs ( object )  getdocs ( object ,   typesig ;   kws ... )   Accepts objects of any type and tries to convert them to  Binding s before searching for the  Binding  in the docsystem.  Note that when conversion fails this method returns an empty  Vector{DocStr} .  source  #  Documenter.DocSystem.multidoc     Function .  Construct a  MultiDoc  object from the provided argument.  Valid inputs are:   Markdown.MD  Docs.FuncDoc  Docs.TypeDoc   source", 
            "title": "DocSystem"
        }, 
        {
            "location": "/lib/internals/documents/", 
            "text": "Documents\n\n\n#\n\n\nDocumenter.Documents\n \n \nModule\n.\n\n\nDefines \nDocument\n and its supporting types\n\n\n\n\nPage\n\n\nUser\n\n\nInternal\n\n\nGlobals\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Document\n \n \nType\n.\n\n\nRepresents an entire document.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Globals\n \n \nType\n.\n\n\nPage\n-local values such as current module that are shared between nodes in a page.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Internal\n \n \nType\n.\n\n\nPrivate state used to control the generation process.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.NavNode\n \n \nType\n.\n\n\nElement in the navigation tree of a document, containing navigation references to other page, reference to the \nPage\n object etc.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Page\n \n \nType\n.\n\n\nRepresents a single markdown file.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.User\n \n \nType\n.\n\n\nUser-specified values used to control the generation process.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.navpath\n \n \nMethod\n.\n\n\nConstructs a list of the ancestors of the \nnavnode\n (inclding the \nnavnode\n itself), ordered so that the root of the navigation tree is the first and \nnavnode\n itself is the last item.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.populate!\n \n \nMethod\n.\n\n\nSignatures\n\n\npopulate!\n(\ndocument\n)\n\n\n\n\n\n\nPopulates the \nContentsNode\ns and \nIndexNode\ns of the \ndocument\n with links.\n\n\nThis can only be done after all the blocks have been expanded (and nodes constructed), because the items have to exist before we can gather the links to those items.\n\n\nsource", 
            "title": "Documents"
        }, 
        {
            "location": "/lib/internals/documents/#documents", 
            "text": "#  Documenter.Documents     Module .  Defines  Document  and its supporting types   Page  User  Internal  Globals   source  #  Documenter.Documents.Document     Type .  Represents an entire document.  source  #  Documenter.Documents.Globals     Type .  Page -local values such as current module that are shared between nodes in a page.  source  #  Documenter.Documents.Internal     Type .  Private state used to control the generation process.  source  #  Documenter.Documents.NavNode     Type .  Element in the navigation tree of a document, containing navigation references to other page, reference to the  Page  object etc.  source  #  Documenter.Documents.Page     Type .  Represents a single markdown file.  source  #  Documenter.Documents.User     Type .  User-specified values used to control the generation process.  source  #  Documenter.Documents.navpath     Method .  Constructs a list of the ancestors of the  navnode  (inclding the  navnode  itself), ordered so that the root of the navigation tree is the first and  navnode  itself is the last item.  source  #  Documenter.Documents.populate!     Method .  Signatures  populate! ( document )   Populates the  ContentsNode s and  IndexNode s of the  document  with links.  This can only be done after all the blocks have been expanded (and nodes constructed), because the items have to exist before we can gather the links to those items.  source", 
            "title": "Documents"
        }, 
        {
            "location": "/lib/internals/dom/", 
            "text": "DOM\n\n\n#\n\n\nDocumenter.Utilities.DOM\n \n \nModule\n.\n\n\nProvides a domain specific language for representing HTML documents.\n\n\nExamples\n\n\nusing\n \nDocumenter\n.\nUtilities\n.\nDOM\n\n\n\n# `DOM` does not export any HTML tags. Define the ones we actually need.\n\n\n@\ntags\n \ndiv\n \np\n \nem\n \nstrong\n \nul\n \nli\n\n\n\ndiv\n(\n\n    \np\n(\nThis \n,\n \nem\n(\nis\n),\n \n a \n,\n \nstrong\n(\nparagraph.\n),\n\n    \np\n(\nAnd this is \n,\n \nstrong\n(\nanother\n),\n \n one\n),\n\n    \nul\n(\n\n        \nli\n(\nand\n),\n\n        \nli\n(\nan\n),\n\n        \nli\n(\nunordered\n),\n\n        \nli\n(\nlist\n)\n\n    \n)\n\n\n)\n\n\n\n\n\n\nNotes\n\n\nAll the arguments passed to a node are flattened into a single vector rather than preserving any nested structure. This means that passing two vectors of nodes to a \ndiv\n will result in a \ndiv\n node with a single vector of children (the concatenation of the two vectors) rather than two vector children. The only arguments that are not flattened are nested nodes.\n\n\nString arguments are automatically converted into text nodes. Text nodes do not have any children or attributes and when displayed the string is escaped using \nescapehtml\n.\n\n\nAttributes\n\n\nAs well as plain nodes shown in the previous example, nodes can have attributes added to them using the following syntax.\n\n\ndiv\n[\n.my-class\n](\n\n    \nimg\n[:\nsrc\n \n=\n \nfoo.jpg\n],\n\n    \ninput\n[\n#my-id\n,\n \n:\ndisabled\n]\n\n\n)\n\n\n\n\n\n\nIn the above example we add a \nclass = \"my-class\"\n attribute to the \ndiv\n node, a \nsrc = \"foo.jpg\"\n to the \nimg\n, and \nid = \"my-id\" disabled\n attributes to the \ninput\n node.\n\n\nThe following syntax is supported within \n[...]\n:\n\n\ntag\n[\n#id\n]\n\n\ntag\n[\n.class\n]\n\n\ntag\n[\n.class#id\n]\n\n\ntag\n[:\ndisabled\n]\n\n\ntag\n[:\nsrc\n \n=\n \nfoo.jpg\n]\n\n\n# ... or any combination of the above arguments.\n\n\n\n\n\n\nInternal Representation\n\n\nThe \n@tags\n macro defines named \nTag\n objects as follows\n\n\n@\ntags\n \ndiv\n \np\n \nem\n \nstrong\n\n\n\n\n\n\nexpands to\n\n\nconst\n \ndiv\n,\n \np\n,\n \nem\n,\n \nstrong\n \n=\n \nTag\n(:\ndiv\n),\n \nTag\n(:\np\n),\n \nTag\n(:\nem\n),\n \nTag\n(:\nstrong\n)\n\n\n\n\n\n\nThese \nTag\n objects are lightweight representations of empty HTML elements without any attributes and cannot be used to represent a complete document. To create an actual tree of HTML elements that can be rendered we need to add some attributes and/or child elements using \ngetindex\n or \ncall\n syntax. Applying either to a \nTag\n object will construct a new \nNode\n object.\n\n\ntag\n(\n...\n)\n      \n# No attributes.\n\n\ntag\n[\n...\n]\n      \n# No children.\n\n\ntag\n[\n...\n](\n...\n)\n \n# Has both attributes and children.\n\n\n\n\n\n\nAll three of the above syntaxes return a new \nNode\n object. Printing of \nNode\n objects is defined using the standard Julia display functions, so only needs a call to \nprint\n to print out a valid HTML document with all nessesary text escaped.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.DOM.@tags\n \n \nMacro\n.\n\n\nDefine a collection of \nTag\n objects and bind them to constants with the same names.\n\n\nExamples\n\n\nDefined globally within a module:\n\n\n@\ntags\n \ndiv\n \nul\n \nli\n\n\n\n\n\n\nDefined within the scope of a function to avoid cluttering the global namespace:\n\n\nfunction\n template\n(\nargs\n...\n)\n\n    \n@\ntags\n \ndiv\n \nul\n \nli\n\n    \n# ...\n\n\nend\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.DOM.Node\n \n \nType\n.\n\n\nRepresents an element within an HTML document including any textual content, children \nNode\ns, and attributes.\n\n\nThis type should not be constructed directly, but instead via \n(...)\n and \n[...]\n applied to a \nTag\n or another \nNode\n object.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.DOM.Tag\n \n \nType\n.\n\n\nRepresents a empty and attribute-less HTML element.\n\n\nUse \n@tags\n to define instances of this type rather than manually creating them via \nTag(:tagname)\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.DOM.escapehtml\n \n \nMethod\n.\n\n\nEscape characters in the provided string. This converts the following characters:\n\n\n\n\n to \nlt;\n\n\n to \ngt;\n\n\n to \namp;\n\n\n'\n to \n#39;\n\n\n\"\n to \nquot;\n\n\n\n\nWhen no escaping is needed then the same object is returned, otherwise a new string is constructed with the characters escaped. The returned object should always be treated as an immutable copy and compared using \n==\n rather than \n===\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.DOM.flatten!\n \n \nMethod\n.\n\n\nSignatures\n\n\nflatten!\n(\nf!\n,\n \nout\n,\n \nx\n::\nAtom\n)\n\n\nflatten!\n(\nf!\n,\n \nout\n,\n \nxs\n)\n\n\n\n\n\n\nFlatten the contents the third argument into the second after applying the function \nf!\n to the element.\n\n\nsource", 
            "title": "DOM"
        }, 
        {
            "location": "/lib/internals/dom/#dom", 
            "text": "#  Documenter.Utilities.DOM     Module .  Provides a domain specific language for representing HTML documents.  Examples  using   Documenter . Utilities . DOM  # `DOM` does not export any HTML tags. Define the ones we actually need.  @ tags   div   p   em   strong   ul   li  div ( \n     p ( This  ,   em ( is ),    a  ,   strong ( paragraph. ), \n     p ( And this is  ,   strong ( another ),    one ), \n     ul ( \n         li ( and ), \n         li ( an ), \n         li ( unordered ), \n         li ( list ) \n     )  )   Notes  All the arguments passed to a node are flattened into a single vector rather than preserving any nested structure. This means that passing two vectors of nodes to a  div  will result in a  div  node with a single vector of children (the concatenation of the two vectors) rather than two vector children. The only arguments that are not flattened are nested nodes.  String arguments are automatically converted into text nodes. Text nodes do not have any children or attributes and when displayed the string is escaped using  escapehtml .  Attributes  As well as plain nodes shown in the previous example, nodes can have attributes added to them using the following syntax.  div [ .my-class ]( \n     img [: src   =   foo.jpg ], \n     input [ #my-id ,   : disabled ]  )   In the above example we add a  class = \"my-class\"  attribute to the  div  node, a  src = \"foo.jpg\"  to the  img , and  id = \"my-id\" disabled  attributes to the  input  node.  The following syntax is supported within  [...] :  tag [ #id ]  tag [ .class ]  tag [ .class#id ]  tag [: disabled ]  tag [: src   =   foo.jpg ]  # ... or any combination of the above arguments.   Internal Representation  The  @tags  macro defines named  Tag  objects as follows  @ tags   div   p   em   strong   expands to  const   div ,   p ,   em ,   strong   =   Tag (: div ),   Tag (: p ),   Tag (: em ),   Tag (: strong )   These  Tag  objects are lightweight representations of empty HTML elements without any attributes and cannot be used to represent a complete document. To create an actual tree of HTML elements that can be rendered we need to add some attributes and/or child elements using  getindex  or  call  syntax. Applying either to a  Tag  object will construct a new  Node  object.  tag ( ... )        # No attributes.  tag [ ... ]        # No children.  tag [ ... ]( ... )   # Has both attributes and children.   All three of the above syntaxes return a new  Node  object. Printing of  Node  objects is defined using the standard Julia display functions, so only needs a call to  print  to print out a valid HTML document with all nessesary text escaped.  source  #  Documenter.Utilities.DOM.@tags     Macro .  Define a collection of  Tag  objects and bind them to constants with the same names.  Examples  Defined globally within a module:  @ tags   div   ul   li   Defined within the scope of a function to avoid cluttering the global namespace:  function  template ( args ... ) \n     @ tags   div   ul   li \n     # ...  end   source  #  Documenter.Utilities.DOM.Node     Type .  Represents an element within an HTML document including any textual content, children  Node s, and attributes.  This type should not be constructed directly, but instead via  (...)  and  [...]  applied to a  Tag  or another  Node  object.  source  #  Documenter.Utilities.DOM.Tag     Type .  Represents a empty and attribute-less HTML element.  Use  @tags  to define instances of this type rather than manually creating them via  Tag(:tagname) .  source  #  Documenter.Utilities.DOM.escapehtml     Method .  Escape characters in the provided string. This converts the following characters:    to  lt;   to  gt;   to  amp;  '  to  #39;  \"  to  quot;   When no escaping is needed then the same object is returned, otherwise a new string is constructed with the characters escaped. The returned object should always be treated as an immutable copy and compared using  ==  rather than  === .  source  #  Documenter.Utilities.DOM.flatten!     Method .  Signatures  flatten! ( f! ,   out ,   x :: Atom )  flatten! ( f! ,   out ,   xs )   Flatten the contents the third argument into the second after applying the function  f!  to the element.  source", 
            "title": "DOM"
        }, 
        {
            "location": "/lib/internals/expanders/", 
            "text": "Expanders\n\n\n#\n\n\nDocumenter.Expanders\n \n \nModule\n.\n\n\nDefines node \"expanders\" that transform nodes from the parsed markdown files.\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.AutoDocsBlocks\n \n \nType\n.\n\n\nParses each code block where the language is \n@autodocs\n and replaces it with all the docstrings that match the provided key/value pairs \nModules = ...\n and \nOrder = ...\n.\n\n\n```@\nautodocs\n\n\nModules\n \n=\n \n[\nFoo\n,\n \nBar\n]\n\n\nOrder\n   \n=\n \n[\n:\nfunction\n,\n \n:\ntype\n]\n\n\n```\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.ContentsBlocks\n \n \nType\n.\n\n\nParses each code block where the language is \n@contents\n and replaces it with a nested list of all \nHeader\n nodes in the generated document. The pages and depth of the list can be set using \nPages = [...]\n and \nDepth = N\n where \nN\n is and integer.\n\n\n```@contents\nPages = [\nfoo.md\n, \nbar.md\n]\nDepth = 1\n```\n\n\n\n\n\nThe default \nDepth\n value is \n2\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.DocsBlocks\n \n \nType\n.\n\n\nParses each code block where the language is \n@docs\n and evaluates the expressions found within the block. Replaces the block with the docstrings associated with each expression.\n\n\n```@docs\nDocumenter\nmakedocs\ndeploydocs\n```\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.EvalBlocks\n \n \nType\n.\n\n\nParses each code block where the language is \n@eval\n and evaluates it's content. Replaces the block with the value resulting from the evaluation. This can be useful for inserting generated content into a document such as plots.\n\n\n```@eval\nusing PyPlot\nx = linspace(-\u03c0, \u03c0)\ny = sin(x)\nplot(x, y, color = \nred\n)\nsavefig(\nplot.svg\n)\nMarkdown.parse(\n![Plot](plot.svg)\n)\n```\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.ExampleBlocks\n \n \nType\n.\n\n\nParses each code block where the language is \n@example\n and evaluates the parsed Julia code found within. The resulting value is then inserted into the final document after the source code.\n\n\n```@example\na = 1\nb = 2\na + b\n```\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.ExpanderPipeline\n \n \nType\n.\n\n\nThe default node expander \"pipeline\", which consists of the following expanders:\n\n\n\n\nTrackHeaders\n\n\nMetaBlocks\n\n\nDocsBlocks\n\n\nAutoDocsBlocks\n\n\nEvalBlocks\n\n\nIndexBlocks\n\n\nContentsBlocks\n\n\nExampleBlocks\n\n\nREPLBlocks\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.IndexBlocks\n \n \nType\n.\n\n\nParses each code block where the language is \n@index\n and replaces it with an index of all docstrings spliced into the document. The pages that are included can be set using a key/value pair \nPages = [...]\n such as\n\n\n```@index\nPages = [\nfoo.md\n, \nbar.md\n]\n```\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.MetaBlocks\n \n \nType\n.\n\n\nParses each code block where the language is \n@meta\n and evaluates the key/value pairs found within the block, i.e.\n\n\n```@meta\nCurrentModule = Documenter\nDocTestSetup  = quote\n    using Documenter\nend\n```\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.REPLBlocks\n \n \nType\n.\n\n\nSimilar to the \nExampleBlocks\n expander, but inserts a Julia REPL prompt before each toplevel expression in the final document.\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.TrackHeaders\n \n \nType\n.\n\n\nTracks all \nMarkdown.Header\n nodes found in the parsed markdown files and stores an \nAnchors.Anchor\n object for each one.\n\n\nsource", 
            "title": "Expanders"
        }, 
        {
            "location": "/lib/internals/expanders/#expanders", 
            "text": "#  Documenter.Expanders     Module .  Defines node \"expanders\" that transform nodes from the parsed markdown files.  source  #  Documenter.Expanders.AutoDocsBlocks     Type .  Parses each code block where the language is  @autodocs  and replaces it with all the docstrings that match the provided key/value pairs  Modules = ...  and  Order = ... .  ```@ autodocs  Modules   =   [ Foo ,   Bar ]  Order     =   [ : function ,   : type ]  ```   source  #  Documenter.Expanders.ContentsBlocks     Type .  Parses each code block where the language is  @contents  and replaces it with a nested list of all  Header  nodes in the generated document. The pages and depth of the list can be set using  Pages = [...]  and  Depth = N  where  N  is and integer.  ```@contents\nPages = [ foo.md ,  bar.md ]\nDepth = 1\n```  The default  Depth  value is  2 .  source  #  Documenter.Expanders.DocsBlocks     Type .  Parses each code block where the language is  @docs  and evaluates the expressions found within the block. Replaces the block with the docstrings associated with each expression.  ```@docs\nDocumenter\nmakedocs\ndeploydocs\n```  source  #  Documenter.Expanders.EvalBlocks     Type .  Parses each code block where the language is  @eval  and evaluates it's content. Replaces the block with the value resulting from the evaluation. This can be useful for inserting generated content into a document such as plots.  ```@eval\nusing PyPlot\nx = linspace(-\u03c0, \u03c0)\ny = sin(x)\nplot(x, y, color =  red )\nsavefig( plot.svg )\nMarkdown.parse( ![Plot](plot.svg) )\n```  source  #  Documenter.Expanders.ExampleBlocks     Type .  Parses each code block where the language is  @example  and evaluates the parsed Julia code found within. The resulting value is then inserted into the final document after the source code.  ```@example\na = 1\nb = 2\na + b\n```  source  #  Documenter.Expanders.ExpanderPipeline     Type .  The default node expander \"pipeline\", which consists of the following expanders:   TrackHeaders  MetaBlocks  DocsBlocks  AutoDocsBlocks  EvalBlocks  IndexBlocks  ContentsBlocks  ExampleBlocks  REPLBlocks   source  #  Documenter.Expanders.IndexBlocks     Type .  Parses each code block where the language is  @index  and replaces it with an index of all docstrings spliced into the document. The pages that are included can be set using a key/value pair  Pages = [...]  such as  ```@index\nPages = [ foo.md ,  bar.md ]\n```  source  #  Documenter.Expanders.MetaBlocks     Type .  Parses each code block where the language is  @meta  and evaluates the key/value pairs found within the block, i.e.  ```@meta\nCurrentModule = Documenter\nDocTestSetup  = quote\n    using Documenter\nend\n```  source  #  Documenter.Expanders.REPLBlocks     Type .  Similar to the  ExampleBlocks  expander, but inserts a Julia REPL prompt before each toplevel expression in the final document.  source  #  Documenter.Expanders.TrackHeaders     Type .  Tracks all  Markdown.Header  nodes found in the parsed markdown files and stores an  Anchors.Anchor  object for each one.  source", 
            "title": "Expanders"
        }, 
        {
            "location": "/lib/internals/formats/", 
            "text": "Formats\n\n\n#\n\n\nDocumenter.Formats\n \n \nModule\n.\n\n\nFiletypes used to decide which rendering methods in \nDocumenter.Writers\n are called.\n\n\nThe only supported format is currently \nMarkdown\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Formats.Format\n \n \nType\n.\n\n\nRepresents the output format. Possible values are \nMarkdown\n, \nLaTeX\n, and \nHTML\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Formats.mimetype\n \n \nMethod\n.\n\n\nSignatures\n\n\nmimetype\n(\nf\n)\n\n\n\n\n\n\nConverts a \nFormat\n value to a \nMIME\n type.\n\n\nsource", 
            "title": "Formats"
        }, 
        {
            "location": "/lib/internals/formats/#formats", 
            "text": "#  Documenter.Formats     Module .  Filetypes used to decide which rendering methods in  Documenter.Writers  are called.  The only supported format is currently  Markdown .  source  #  Documenter.Formats.Format     Type .  Represents the output format. Possible values are  Markdown ,  LaTeX , and  HTML .  source  #  Documenter.Formats.mimetype     Method .  Signatures  mimetype ( f )   Converts a  Format  value to a  MIME  type.  source", 
            "title": "Formats"
        }, 
        {
            "location": "/lib/internals/generator/", 
            "text": "Generator\n\n\n#\n\n\nDocumenter.Generator\n \n \nModule\n.\n\n\nProvides the functions related to generating documentation stubs.\n\n\nsource\n\n\n#\n\n\nDocumenter.Generator.gitignore\n \n \nMethod\n.\n\n\nSignatures\n\n\ngitignore\n()\n\n\n\n\n\n\nContents of the default \n.gitignore\n file.\n\n\nsource\n\n\n#\n\n\nDocumenter.Generator.index\n \n \nMethod\n.\n\n\nSignatures\n\n\nindex\n(\npkgname\n)\n\n\n\n\n\n\nContents of the default \nsrc/index.md\n file.\n\n\nsource\n\n\n#\n\n\nDocumenter.Generator.make\n \n \nMethod\n.\n\n\nSignatures\n\n\nmake\n(\npkgname\n)\n\n\n\n\n\n\nContents of the default \nmake.jl\n file.\n\n\nsource\n\n\n#\n\n\nDocumenter.Generator.mkdocs\n \n \nMethod\n.\n\n\nSignatures\n\n\nmkdocs\n(\npkgname\n;\n \ndescription\n,\n \nauthor\n,\n \nurl\n)\n\n\n\n\n\n\nContents of the default \nmkdocs.yml\n file.\n\n\nsource\n\n\n#\n\n\nDocumenter.Generator.savefile\n \n \nMethod\n.\n\n\nSignatures\n\n\nsavefile\n(\nf\n,\n \nroot\n,\n \nfilename\n)\n\n\n\n\n\n\nAttempts to save a file at \n$(root)/$(filename)\n. \nf\n will be called with file stream (see \nopen\n).\n\n\nfilename\n can also be a file in a subdirectory (e.g. \nsrc/index.md\n), and then then subdirectories will be created automatically.\n\n\nsource", 
            "title": "Generator"
        }, 
        {
            "location": "/lib/internals/generator/#generator", 
            "text": "#  Documenter.Generator     Module .  Provides the functions related to generating documentation stubs.  source  #  Documenter.Generator.gitignore     Method .  Signatures  gitignore ()   Contents of the default  .gitignore  file.  source  #  Documenter.Generator.index     Method .  Signatures  index ( pkgname )   Contents of the default  src/index.md  file.  source  #  Documenter.Generator.make     Method .  Signatures  make ( pkgname )   Contents of the default  make.jl  file.  source  #  Documenter.Generator.mkdocs     Method .  Signatures  mkdocs ( pkgname ;   description ,   author ,   url )   Contents of the default  mkdocs.yml  file.  source  #  Documenter.Generator.savefile     Method .  Signatures  savefile ( f ,   root ,   filename )   Attempts to save a file at  $(root)/$(filename) .  f  will be called with file stream (see  open ).  filename  can also be a file in a subdirectory (e.g.  src/index.md ), and then then subdirectories will be created automatically.  source", 
            "title": "Generator"
        }, 
        {
            "location": "/lib/internals/selectors/", 
            "text": "Selectors\n\n\n#\n\n\nDocumenter.Selectors\n \n \nModule\n.\n\n\nAn extensible code selection interface.\n\n\nThe \nSelectors\n module provides an extensible way to write code that has to dispatch on different predicates without hardcoding the control flow into a single chain of \nif\n statements.\n\n\nIn the following example a selector for a simple condition is implemented and the generated selector code is described:\n\n\nabstract\n MySelector\n \n:\n \nSelectors\n.\nAbstractSelector\n\n\n\n# The different cases we want to test.\n\n\nabstract\n One\n    \n:\n \nMySelector\n\n\nabstract\n NotOne\n \n:\n \nMySelector\n\n\n\n# The order in which to test the cases.\n\n\nSelectors\n.\norder\n(::\nType\n{\nOne\n})\n    \n=\n \n0.0\n\n\nSelectors\n.\norder\n(::\nType\n{\nNotOne\n})\n \n=\n \n1.0\n\n\n\n# The predicate to test against.\n\n\nSelectors\n.\nmatcher\n(::\nType\n{\nOne\n},\n \nx\n)\n    \n=\n \nx\n \n===\n \n1\n\n\nSelectors\n.\nmatcher\n(::\nType\n{\nNotOne\n},\n \nx\n)\n \n=\n \nx\n \n!==\n \n1\n\n\n\n# What to do when a test is successful.\n\n\nSelectors\n.\nrunner\n(::\nType\n{\nOne\n},\n \nx\n)\n    \n=\n \nprintln\n(\nfound one\n)\n\n\nSelectors\n.\nrunner\n(::\nType\n{\nNotOne\n},\n \nx\n)\n \n=\n \nprintln\n(\nnot found\n)\n\n\n\n# Test our selector with some numbers.\n\n\nfor\n \ni\n \nin\n \n0\n:\n5\n\n    \nSelectors\n.\ndispatch\n(\nMySelector\n,\n \ni\n)\n\n\nend\n\n\n\n\n\n\nThe code generated by \nSelectors.dispatch(Selector, i)\n will look similar to the following:\n\n\nfunction\n dispatch\n(::\nType\n{\nMySelector\n},\n \ni\n::\nInt\n)\n\n    \nif\n \nmatcher\n(\nOne\n,\n \ni\n)\n\n        \nrunner\n(\nOne\n,\n \ni\n)\n\n    \nelseif\n \nmatcher\n(\nNotOne\n,\n \ni\n)\n\n        \nrunner\n(\nNotOne\n,\n \ni\n)\n\n    \nend\n\n\nend\n\n\n\n\n\n\nwhich would be further simplified after inlining \nmatcher\n and \nrunner\n as\n\n\nfunction\n dispatch\n(::\nType\n{\nMySelector\n},\n \ni\n::\nInt\n)\n\n    \nif\n \ni\n \n===\n \n1\n\n        \nprintln\n(\nfound one\n)\n\n    \nelseif\n \ni\n \n!==\n \n1\n\n        \nprintln\n(\nnot found\n)\n\n    \nend\n\n\nend\n\n\n\n\n\n\nThe module provides the following interface for creating selectors:\n\n\n\n\norder\n\n\nmatcher\n\n\nrunner\n\n\nstrict\n\n\ndisable\n\n\ndispatch\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Selectors.AbstractSelector\n \n \nType\n.\n\n\nRoot selector type. Each user-defined selector must subtype from this, i.e.\n\n\nabstract\n MySelector\n \n:\n \nSelectors\n.\nAbstractSelector\n\n\n\nabstract\n First\n  \n:\n \nMySelector\n\n\nabstract\n Second\n \n:\n \nMySelector\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Selectors.disable\n \n \nMethod\n.\n\n\nDisable a particular case in a selector so that it is never used.\n\n\nSelectors\n.\ndisable\n(::\nType\n{\nDebug\n})\n \n=\n \ntrue\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Selectors.dispatch\n \n \nMethod\n.\n\n\nGenerated function that builds a specialised selector for each selector type provided, i.e.\n\n\nSelectors\n.\ndispatch\n(\nMySelector\n,\n \n1\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Selectors.matcher\n \n \nFunction\n.\n\n\nDefine the matching test for each case in a selector, i.e.\n\n\nSelectors\n.\nmatcher\n(::\nType\n{\nFirst\n},\n \nx\n)\n  \n=\n \nx\n \n==\n \n1\n\n\nSelectors\n.\nmatcher\n(::\nType\n{\nSecond\n},\n \nx\n)\n \n=\n \ntrue\n\n\n\n\n\n\nNote that the return type must be \nBool\n.\n\n\nTo match against multiple cases use the \nSelectors.strict\n function.\n\n\nsource\n\n\n#\n\n\nDocumenter.Selectors.order\n \n \nFunction\n.\n\n\nDefine the precedence of each case in a selector, i.e.\n\n\nSelectors\n.\norder\n(::\nType\n{\nFirst\n})\n  \n=\n \n1.0\n\n\nSelectors\n.\norder\n(::\nType\n{\nSecond\n})\n \n=\n \n2.0\n\n\n\n\n\n\nNote that the return type must be \nFloat64\n. Defining multiple case types to have the same order will result in undefined behaviour.\n\n\nsource\n\n\n#\n\n\nDocumenter.Selectors.runner\n \n \nFunction\n.\n\n\nDefine the code that will run when a particular \nSelectors.matcher\n test returns \ntrue\n, i.e.\n\n\nSelectors\n.\nrunner\n(::\nType\n{\nFirst\n},\n \nx\n)\n  \n=\n \nprintln\n(\n`x` is equal to `1`.\n)\n\n\nSelectors\n.\nrunner\n(::\nType\n{\nSecond\n},\n \nx\n)\n \n=\n \nprintln\n(\n`x` is not equal to `1`.\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Selectors.strict\n \n \nMethod\n.\n\n\nDefine whether a selector case will \"fallthrough\" or not when successfully matched against. By default matching is strict and does not fallthrough to subsequent selector cases.\n\n\n# Adding a debugging selector case.\n\n\nabstract\n Debug\n \n:\n \nMySelector\n\n\n\n# Insert prior to all other cases.\n\n\nSelectors\n.\norder\n(::\nType\n{\nDebug\n})\n \n=\n \n0.0\n\n\n\n# Fallthrough to the next case on success.\n\n\nSelectors\n.\nstrict\n(::\nType\n{\nDebug\n})\n \n=\n \nfalse\n\n\n\n# We always match, regardless of the value of `x`.\n\n\nSelectors\n.\nmatcher\n(::\nType\n{\nDebug\n},\n \nx\n)\n \n=\n \ntrue\n\n\n\n# Print some debugging info.\n\n\nSelectors\n.\nrunner\n(::\nType\n{\nDebug\n},\n \nx\n)\n \n=\n \n@\nshow\n \nx\n\n\n\n\n\n\nsource", 
            "title": "Selectors"
        }, 
        {
            "location": "/lib/internals/selectors/#selectors", 
            "text": "#  Documenter.Selectors     Module .  An extensible code selection interface.  The  Selectors  module provides an extensible way to write code that has to dispatch on different predicates without hardcoding the control flow into a single chain of  if  statements.  In the following example a selector for a simple condition is implemented and the generated selector code is described:  abstract  MySelector   :   Selectors . AbstractSelector  # The different cases we want to test.  abstract  One      :   MySelector  abstract  NotOne   :   MySelector  # The order in which to test the cases.  Selectors . order (:: Type { One })      =   0.0  Selectors . order (:: Type { NotOne })   =   1.0  # The predicate to test against.  Selectors . matcher (:: Type { One },   x )      =   x   ===   1  Selectors . matcher (:: Type { NotOne },   x )   =   x   !==   1  # What to do when a test is successful.  Selectors . runner (:: Type { One },   x )      =   println ( found one )  Selectors . runner (:: Type { NotOne },   x )   =   println ( not found )  # Test our selector with some numbers.  for   i   in   0 : 5 \n     Selectors . dispatch ( MySelector ,   i )  end   The code generated by  Selectors.dispatch(Selector, i)  will look similar to the following:  function  dispatch (:: Type { MySelector },   i :: Int ) \n     if   matcher ( One ,   i ) \n         runner ( One ,   i ) \n     elseif   matcher ( NotOne ,   i ) \n         runner ( NotOne ,   i ) \n     end  end   which would be further simplified after inlining  matcher  and  runner  as  function  dispatch (:: Type { MySelector },   i :: Int ) \n     if   i   ===   1 \n         println ( found one ) \n     elseif   i   !==   1 \n         println ( not found ) \n     end  end   The module provides the following interface for creating selectors:   order  matcher  runner  strict  disable  dispatch   source  #  Documenter.Selectors.AbstractSelector     Type .  Root selector type. Each user-defined selector must subtype from this, i.e.  abstract  MySelector   :   Selectors . AbstractSelector  abstract  First    :   MySelector  abstract  Second   :   MySelector   source  #  Documenter.Selectors.disable     Method .  Disable a particular case in a selector so that it is never used.  Selectors . disable (:: Type { Debug })   =   true   source  #  Documenter.Selectors.dispatch     Method .  Generated function that builds a specialised selector for each selector type provided, i.e.  Selectors . dispatch ( MySelector ,   1 )   source  #  Documenter.Selectors.matcher     Function .  Define the matching test for each case in a selector, i.e.  Selectors . matcher (:: Type { First },   x )    =   x   ==   1  Selectors . matcher (:: Type { Second },   x )   =   true   Note that the return type must be  Bool .  To match against multiple cases use the  Selectors.strict  function.  source  #  Documenter.Selectors.order     Function .  Define the precedence of each case in a selector, i.e.  Selectors . order (:: Type { First })    =   1.0  Selectors . order (:: Type { Second })   =   2.0   Note that the return type must be  Float64 . Defining multiple case types to have the same order will result in undefined behaviour.  source  #  Documenter.Selectors.runner     Function .  Define the code that will run when a particular  Selectors.matcher  test returns  true , i.e.  Selectors . runner (:: Type { First },   x )    =   println ( `x` is equal to `1`. )  Selectors . runner (:: Type { Second },   x )   =   println ( `x` is not equal to `1`. )   source  #  Documenter.Selectors.strict     Method .  Define whether a selector case will \"fallthrough\" or not when successfully matched against. By default matching is strict and does not fallthrough to subsequent selector cases.  # Adding a debugging selector case.  abstract  Debug   :   MySelector  # Insert prior to all other cases.  Selectors . order (:: Type { Debug })   =   0.0  # Fallthrough to the next case on success.  Selectors . strict (:: Type { Debug })   =   false  # We always match, regardless of the value of `x`.  Selectors . matcher (:: Type { Debug },   x )   =   true  # Print some debugging info.  Selectors . runner (:: Type { Debug },   x )   =   @ show   x   source", 
            "title": "Selectors"
        }, 
        {
            "location": "/lib/internals/utilities/", 
            "text": "Utilities\n\n\n#\n\n\nDocumenter.Utilities\n \n \nModule\n.\n\n\nProvides a collection of utility functions and types that are used in other submodules.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.Object\n \n \nType\n.\n\n\nRepresents an object stored in the docsystem by its binding and signature.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.assetsdir\n \n \nMethod\n.\n\n\nReturns the path to the Documenter \nassets\n directory.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.check_kwargs\n \n \nMethod\n.\n\n\nPrints a formatted warning to the user listing unrecognised keyword arguments.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.currentdir\n \n \nMethod\n.\n\n\nReturns the current directory.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.doccat\n \n \nMethod\n.\n\n\nReturns the category name of the provided \nObject\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.docs\n \n \nFunction\n.\n\n\ndocs(ex, str)\n\n\n\n\n\nReturns an expression that, when evaluated, returns the docstrings associated with \nex\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.filterdocs\n \n \nMethod\n.\n\n\nfilterdocs(doc, modules)\n\n\n\n\n\nRemove docstrings from the markdown object, \ndoc\n, that are not from one of \nmodules\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.issubmodule\n \n \nMethod\n.\n\n\nissubmodule(sub, mod)\n\n\n\n\n\nChecks whether \nsub\n is a submodule of \nmod\n. A module is also considered to be its own submodule.\n\n\nE.g. \nA.B.C\n is a submodule of \nA\n, \nA.B\n and \nA.B.C\n, but it is not a submodule of \nD\n, \nA.D\n nor \nA.B.C.D\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.log\n \n \nMethod\n.\n\n\nFormat and print a message to the user.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.logging\n \n \nMethod\n.\n\n\nlogging(flag::Bool)\n\n\n\n\n\nEnable or disable logging output for \nlog\n and \nwarn\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.nodocs\n \n \nMethod\n.\n\n\nDoes the given docstring represent actual documentation or a no docs error message?\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.object\n \n \nMethod\n.\n\n\nobject(ex, str)\n\n\n\n\n\nReturns a expression that, when evaluated, returns an \nObject\n representing \nex\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.parseblock\n \n \nMethod\n.\n\n\nReturns a vector of parsed expressions and their corresponding raw strings.\n\n\nThe keyword argument \nskip = N\n drops the leading \nN\n lines from the input string.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.slugify\n \n \nMethod\n.\n\n\nSlugify a string into a suitable URL.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.srcpath\n \n \nMethod\n.\n\n\nFind the path of a file relative to the \nsource\n directory. \nroot\n is the path to the directory containing the file \nfile\n.\n\n\nIt is meant to be used with \nwalkdir(source)\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.submodules\n \n \nMethod\n.\n\n\nReturns the set of submodules of a given root module/s.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.warn\n \n \nMethod\n.\n\n\nwarn(file, msg)\nwarn(msg)\n\n\n\n\n\nFormat and print a warning message to the user. Passing a \nfile\n will include the filename where the warning was raised.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.withoutput\n \n \nMethod\n.\n\n\nCall a function and capture all \nSTDOUT\n and \nSTDERR\n output.\n\n\nwithoutput(f) --\n (result, success, backtrace, output)\n\n\n\n\n\nwhere\n\n\n\n\nresult\n is the value returned from calling function \nf\n.\n\n\nsuccess\n signals whether \nf\n has thrown an error, in which case \nresult\n stores the \nException\n that was raised.\n\n\nbacktrace\n a \nVector{Ptr{Void}}\n produced by \ncatch_backtrace()\n if an error is thrown.\n\n\noutput\n is the combined output of \nSTDOUT\n and \nSTDERR\n during execution of \nf\n.\n\n\n\n\nsource", 
            "title": "Utilities"
        }, 
        {
            "location": "/lib/internals/utilities/#utilities", 
            "text": "#  Documenter.Utilities     Module .  Provides a collection of utility functions and types that are used in other submodules.  source  #  Documenter.Utilities.Object     Type .  Represents an object stored in the docsystem by its binding and signature.  source  #  Documenter.Utilities.assetsdir     Method .  Returns the path to the Documenter  assets  directory.  source  #  Documenter.Utilities.check_kwargs     Method .  Prints a formatted warning to the user listing unrecognised keyword arguments.  source  #  Documenter.Utilities.currentdir     Method .  Returns the current directory.  source  #  Documenter.Utilities.doccat     Method .  Returns the category name of the provided  Object .  source  #  Documenter.Utilities.docs     Function .  docs(ex, str)  Returns an expression that, when evaluated, returns the docstrings associated with  ex .  source  #  Documenter.Utilities.filterdocs     Method .  filterdocs(doc, modules)  Remove docstrings from the markdown object,  doc , that are not from one of  modules .  source  #  Documenter.Utilities.issubmodule     Method .  issubmodule(sub, mod)  Checks whether  sub  is a submodule of  mod . A module is also considered to be its own submodule.  E.g.  A.B.C  is a submodule of  A ,  A.B  and  A.B.C , but it is not a submodule of  D ,  A.D  nor  A.B.C.D .  source  #  Documenter.Utilities.log     Method .  Format and print a message to the user.  source  #  Documenter.Utilities.logging     Method .  logging(flag::Bool)  Enable or disable logging output for  log  and  warn .  source  #  Documenter.Utilities.nodocs     Method .  Does the given docstring represent actual documentation or a no docs error message?  source  #  Documenter.Utilities.object     Method .  object(ex, str)  Returns a expression that, when evaluated, returns an  Object  representing  ex .  source  #  Documenter.Utilities.parseblock     Method .  Returns a vector of parsed expressions and their corresponding raw strings.  The keyword argument  skip = N  drops the leading  N  lines from the input string.  source  #  Documenter.Utilities.slugify     Method .  Slugify a string into a suitable URL.  source  #  Documenter.Utilities.srcpath     Method .  Find the path of a file relative to the  source  directory.  root  is the path to the directory containing the file  file .  It is meant to be used with  walkdir(source) .  source  #  Documenter.Utilities.submodules     Method .  Returns the set of submodules of a given root module/s.  source  #  Documenter.Utilities.warn     Method .  warn(file, msg)\nwarn(msg)  Format and print a warning message to the user. Passing a  file  will include the filename where the warning was raised.  source  #  Documenter.Utilities.withoutput     Method .  Call a function and capture all  STDOUT  and  STDERR  output.  withoutput(f) --  (result, success, backtrace, output)  where   result  is the value returned from calling function  f .  success  signals whether  f  has thrown an error, in which case  result  stores the  Exception  that was raised.  backtrace  a  Vector{Ptr{Void}}  produced by  catch_backtrace()  if an error is thrown.  output  is the combined output of  STDOUT  and  STDERR  during execution of  f .   source", 
            "title": "Utilities"
        }, 
        {
            "location": "/lib/internals/walkers/", 
            "text": "Walkers\n\n\n#\n\n\nDocumenter.Walkers\n \n \nModule\n.\n\n\nProvides the \nwalk\n function.\n\n\nsource\n\n\n#\n\n\nDocumenter.Walkers.walk\n \n \nMethod\n.\n\n\nSignatures\n\n\nwalk\n(\nf\n,\n \nmeta\n,\n \nelement\n)\n\n\n\n\n\n\nCalls \nf\n on \nelement\n and any of its child elements. \nmeta\n is a \nDict\n containing metadata such as current module.\n\n\nsource", 
            "title": "Walkers"
        }, 
        {
            "location": "/lib/internals/walkers/#walkers", 
            "text": "#  Documenter.Walkers     Module .  Provides the  walk  function.  source  #  Documenter.Walkers.walk     Method .  Signatures  walk ( f ,   meta ,   element )   Calls  f  on  element  and any of its child elements.  meta  is a  Dict  containing metadata such as current module.  source", 
            "title": "Walkers"
        }, 
        {
            "location": "/lib/internals/writers/", 
            "text": "Writers\n\n\n#\n\n\nDocumenter.Writers\n \n \nModule\n.\n\n\nProvides a rendering function, \nrender\n, for writing each supported \nFormats.Format\n to file.\n\n\nNote that currently \nFormats.Markdown\n is the \nonly\n supported format.\n\n\nsource\n\n\n#\n\n\nDocumenter.Writers.Writer\n \n \nType\n.\n\n\nA parametric type that allows us to use multiple dispatch to pick the appropriate writer for each output format.\n\n\nThe parameter \nf\n should be an instance of the \nFormats.Format\n enumeration.\n\n\nsource\n\n\n#\n\n\nDocumenter.Writers.render\n \n \nMethod\n.\n\n\nWrites a \nDocuments.Document\n object to \n.user.build\n directory in the format specified in \n.user.format\n.\n\n\nThe method should be overloaded in each writer as\n\n\nrender(::Writer{format}, doc)\n\n\n\n\n\nwhere \nformat\n is one of the values of the \nFormats.Format\n enumeration.\n\n\nsource\n\n\n#\n\n\nDocumenter.Writers.MarkdownWriter\n \n \nModule\n.\n\n\nProvides the \nrender\n methods to write the documentation as Markdown files (\nMIME\"text/plain\"\n).\n\n\nsource\n\n\n#\n\n\nDocumenter.Writers.HTMLWriter\n \n \nModule\n.\n\n\nProvides the \nrender\n methods to write the documentation as HTML files (\nMIME\"text/html\"\n).\n\n\nsource\n\n\n#\n\n\nDocumenter.Writers.HTMLWriter.mdconvert\n \n \nMethod\n.\n\n\nConvert a markdown object to a \nDOM.Node\n object.\n\n\nThe \nparent\n argument is passed to allow for context-dependant conversions.\n\n\nsource\n\n\n#\n\n\nDocumenter.Writers.LaTeXWriter\n \n \nModule\n.\n\n\nProvides the \nrender\n methods to write the documentation as LaTeX files (\nMIME\"text/latex\"\n).\n\n\nsource", 
            "title": "Writers"
        }, 
        {
            "location": "/lib/internals/writers/#writers", 
            "text": "#  Documenter.Writers     Module .  Provides a rendering function,  render , for writing each supported  Formats.Format  to file.  Note that currently  Formats.Markdown  is the  only  supported format.  source  #  Documenter.Writers.Writer     Type .  A parametric type that allows us to use multiple dispatch to pick the appropriate writer for each output format.  The parameter  f  should be an instance of the  Formats.Format  enumeration.  source  #  Documenter.Writers.render     Method .  Writes a  Documents.Document  object to  .user.build  directory in the format specified in  .user.format .  The method should be overloaded in each writer as  render(::Writer{format}, doc)  where  format  is one of the values of the  Formats.Format  enumeration.  source  #  Documenter.Writers.MarkdownWriter     Module .  Provides the  render  methods to write the documentation as Markdown files ( MIME\"text/plain\" ).  source  #  Documenter.Writers.HTMLWriter     Module .  Provides the  render  methods to write the documentation as HTML files ( MIME\"text/html\" ).  source  #  Documenter.Writers.HTMLWriter.mdconvert     Method .  Convert a markdown object to a  DOM.Node  object.  The  parent  argument is passed to allow for context-dependant conversions.  source  #  Documenter.Writers.LaTeXWriter     Module .  Provides the  render  methods to write the documentation as LaTeX files ( MIME\"text/latex\" ).  source", 
            "title": "Writers"
        }
    ]
}